# -*- coding: utf-8 -*-
"""CodeWars - 3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HCyxi7C6RUpTTfC7IVCR4ws20CzH86lX

# Задача 229(8) Did she say hallo?

You received a whatsup message from an unknown number. Could it be from that girl/boy with a foreign accent you met yesterday evening?

Write a simple function to check if the string contains the word hallo in different languages.

These are the languages of the possible people you met the night before:

hello - english

ciao - italian

salut - french

hallo - german

hola - spanish

ahoj - czech republic

czesc - polish

Notes

you can assume the input is a string.
to keep this a beginner exercise you don't need to check if the greeting is a subset of word (Hallowen can pass the test)
function should be case insensitive to pass the tests
"""

#0
def validate_hello(greetings):
    greetings = greetings.lower()
    
    greet = ['hello', 'ciao', 'salut', 'hallo', 'hola', 'ahoj', 'czesc']
    
    for i in greet:
        if i in greetings:
            return True
        
    return False

#1
def validate_hello(greetings):
    return any(x in greetings.lower() for x in ['hello','ciao','salut','hallo','hola','ahoj','czesc'])

#2
from re import compile, search, I

REGEX = compile(r'hello|ciao|salut|hallo|hola|ahoj|czesc', I)


def validate_hello(greeting):
    return bool(search(REGEX, greeting))


#3
import re

def validate_hello(greetings):
    return bool(re.search("h[ae]llo|ciao|salut|hola|ahoj|czesc", greetings.lower()))

#4
import re
def validate_hello(greetings):
    return True if re.findall('hello|ciao|salut|hallo|hola|ahoj|czesc', greetings, re.IGNORECASE) else False


#5
import re

check = re.compile(r"hello|ciao|salut|hallo|hola|ahoj|czesc", re.IGNORECASE).search

def validate_hello(greetings):
    return bool(check(greetings))


#6
import re

def validate_hello(greetings):
    return bool(re.search('ahoj|h[ea]llo|hola|czesc|ciao|salut', greetings, re.I))

"""# Задача 230(7) L2: Triple X

Given a string, return true if the first instance of "x" in the string is immediately followed by the string "xx".

triple_x(""), False)

tripleX("abraxxxas") → true

tripleX("xoxotrololololololoxxx") → false

tripleX("softX kitty, warm kitty, xxxxx") → true

tripleX("softx kitty, warm kitty, xxxxx") → false

Note :

capital X's do not count as an occurrence of "x".
if there are no "x"'s then return false
"""

#0
def triple_x(s):
    for i in range(len(s)-2):
        if s[i] == 'x':
            if s[i+1] == 'x':
                if s[i+2] == 'x':
                    return True
            else: 
                return False     
    return False

#1
def triple_x(s: str) -> bool:
    return 0 <= s.find("x") == s.find("xxx") 


#2
def triple_x(s):
    try:
        return True if s.index("x")==s.index("xxx") else False
    except: return False


#3
import re

def triple_x(s):
    return re.match('[^x]*xxx', s) is not None

#4
def triple_x(s):
    pos=s.find('x')
    return s[pos:pos+3]=='xxx'

#5
    for x in range(len(s)):
        if s[x] == 'x':
            return s[x+1:x+3] == 'xx'
    return 0

#6
triple_x=lambda s:s.find('x')==s.find('xxx')>-1

#7
def triple_x(s):
    return s.find("xxx") == s.find("x") != -1

#8
def triple_x(s):
    return s[s.find('x'):].startswith('xxx')

Метод center( width, [fill] ) возвращает строку длиной width, 
в которой исходная строка находится в центре, а справа и слева от нее находятся символы указанные в fillchar ( по умолчанию пробел ).

str = 'python Scripts'

str.center(16, '_')
# _python Scripts_

"""# Задача 321(8) Safen User Input Part I - htmlspecialchars

afen User Input Part I - htmlspecialchars
You are a(n) novice/average/experienced/professional/world-famous Web Developer (choose one) who owns a(n) simple/clean/slick/beautiful/complicated/professional/business website (choose one or more) which contains form fields so visitors can send emails or leave a comment on your website with ease. However, with ease comes danger. Every now and then, a hacker visits your website and attempts to compromise it through the use of XSS (Cross Site Scripting). This is done by injecting script tags into the website through form fields which may contain malicious code (e.g. a redirection to a malicious website that steals personal information).

Mission

Your mission is to implement a function that converts the following potentially harmful characters:

< --> &lt;

> --> &gt;

" --> &quot;

& --> &amp;

Good luck :D

Extension

If you are an experienced programmer, try shortening your code as much as possible and optimise it to minimise run time. Experienced programmers should be able to complete this exercise in one line of code.
"""

#0 
def html_special_chars(data): 
    symbol = {"<":"&lt;", ">":"&gt;", '"':"&quot;", "&":"&amp;"}
    s = ""
    for i in data:
        if i in symbol:
            s += symbol[i]
        else:    
            s += i
    return s

#1
def html_special_chars(data): 
    symbols = {'<': '&lt;', '>': '&gt;', '"': '&quot;', '&': '&amp;'}
    return "".join(symbols.get(x, x) for x in data)

#2
def html_special_chars(data): 
    return data.translate(str.maketrans({'<':'&lt;','>':'&gt;','"':'&quot;','&':'&amp;'}))

#3
def html_special_chars(data): 
    return data.replace('&', "&amp;").replace('>', "&gt;").replace('<', "&lt;").replace('\"', "&quot;")

#4
html_special_chars = lambda s: s.translate({60: "&lt;", 62: "&gt;", 34: "&quot;", 38: "&amp;"})

"""# Задача 322(7) Char Code Calculation

Given a string, turn each character into its ASCII character code and join them together to create a number - let's call this number total1:

'ABC' --> 'A' = 65, 'B' = 66, 'C' = 67 --> 656667

Then replace any incidence of the number 7 with the number 1, and call this number 'total2':

total1 = 656667
              ^
total2 = 656661
              ^
Then return the difference between the sum of the digits in total1 and total2:

  (6 + 5 + 6 + 6 + 6 + 7)

  (6 + 5 + 6 + 6 + 6 + 1)

-------------------------

                       6

calc('abcdef'), 6

calc('ifkhchlhfd'), 6

calc('aaaaaddddr'), 30

calc('jfmgklf8hglbe'), 6

calc('jaam'), 12
"""

#0 
def calc(x):
    s = ''

    for i in x:
        s += str(ord(i))


    total1 = list(s)
    total2 = list(s)


    for i, item in enumerate(total2):
        if item == '7':
            total2[i] = '1'


    n = 0

    for i in range(len(total1)):
        n += (int(total1[i]) - int(total2[i]))
        
    return n

#1
def calc(s):
    total1 = ''.join(map(lambda c: str(ord(c)), s))
    total2 = total1.replace('7', '1')
    return sum(map(int, total1)) - sum(map(int, total2))

#2
def calc(x):
    return ''.join(str(ord(ch)) for ch in x).count('7') * 6

#3
def calc(x):
    total1 = "".join(str(ord(char)) for char in x)
    total2 = total1.replace("7","1")
    return sum(int(x) for x in total1) - sum(int(x) for x in total2)

#4
def calc(x):
    return sum(6 for c in ''.join(map(str, map(ord, x))) if c== '7')

#5
def calc(x):
    return ''.join([str(ord(x[i])) for i in range(len(x)) ]).count('7') * 6

#6
def calc(x):
    s = ''.join( str(ord(c)) for c in x )
    
    return 6*( s.count('7') )

#7
def calc(x):
    t1: str = "".join(str(ord(l)) for l in x)
    t2: str = t1.replace('7', '1')
    return sum(int(i) for i in t1) - sum(int(i) for i in t2)

#8
def calc(x):
    total1=int(''.join(str(ord(n)) for n in x))
    total2=int(''.join(str(ord(n)) for n in x).replace('7','1'))
    return sum(map(int,str(total1)))-sum(map(int,str(total2)))

"""# Задача 323(8) Check same case"""

Write a function that will check if two given characters are the same case.

If any of characters is not a letter, return -1
If both characters are the same case, return 1
If both characters are letters and not the same case, return 0
Examples
'a' and 'g' returns 1

'A' and 'C' returns 1

'b' and 'G' returns 0

'B' and 'g' returns 0

'0' and '?' returns -1

#0
def same_case(a, b): 
    #if isinstance(a, str) & isinstance(b, str):
    if a.isalpha() and b.isalpha():
        if a.islower() and b.islower(): 
            return 1
        elif a.isupper() and b.isupper():
            return 1
        
        else:
            return 0
    else:
        return -1

#1
def same_case(a, b):
    return a.isupper() == b.isupper() if a.isalpha() and b.isalpha() else -1

#2
def same_case(a, b): 
    c = a+b
    if not c.isalpha():
        return -1
    if c.islower() or c.isupper():
        return 1
    else:
        return 0

#3
def same_case(a, b):
    return -1 if not (a+b).isalpha() else a.isupper() == b.isupper()

"""# Задача 324(7) Simple Fun #176: Reverse Letter

Task

Given a string str, reverse it omitting all non-alphabetic characters.

Example

For str = "krishan", the output should be "nahsirk".

For str = "ultr53o?n", the output should be "nortlu".

Input/Output

[input] string str

A string consists of lowercase latin letters, digits and symbols.
"""

#0
def reverse_letter(string):
    s = ''
    for i in reversed(string):
        if i.isalpha():
            s += i
    return s

#1
def reverse_letter(string):
    return "".join([i  for i in reversed(string) if i.isalpha()])

#2
def reverse_letter(string):
    return ''.join(filter(str.isalpha, reversed(string)))

#3
import re
def reverse_letter(string):
    return re.sub("[^a-zA-Z]","",string)[::-1]

#4
reverse_letter = lambda s:''.join(reversed([x for x in s if x.isalpha()]))

"""# Задача 325(7) Dot Calculator

Dot Calculator
You have to write a calculator that receives strings for input. The dots will represent the number in the equation. There will be dots on one side, an operator, and dots again after the oparator. The dots and the operator will be separated by one space.

Here are the following valid operators :

+ Addition

- Subtraction

* Multiplication

// Integer Division

Your Work (Task)

You'll have to return a string that contains dots, as many the equation returns. If the result is 0, return the empty string. When it comes to subtraction, the first number will always be greater than or equal to the second number.

Examples

calculator("..... + ...............") => "...................."

calculator("..... - ...") => ".."

calculator("..... - .") => "...."

calculator("..... * ...") => "..............."

calculator("..... * ..") => ".........."

calculator("..... // ..") => ".."

calculator("..... // .") => "....."

calculator(". // ..") => ""

calculator(".. - ..") => ""
"""

#0 
def calculator(txt):
    if '+' in txt:
        s = txt.split('+')
        c1 = s[0].count('.')
        c2 = s[1].count('.')
        return (c1 + c2) * '.'
    elif '-' in txt:
        s = txt.split('-')
        c1 = s[0].count('.')
        c2 = s[1].count('.')
        if c1 - c2 == 0:
            return ""
        return (c1 - c2) * '.'
    elif '*' in txt:
        s = txt.split('*')
        c1 = s[0].count('.')
        c2 = s[1].count('.')
        return (c1 * c2) * '.'
    elif '//' in txt:
        s = txt.split('//')
        c1 = s[0].count('.')
        c2 = s[1].count('.')
        return (c1 // c2) * '.'

#1
def calculator(txt):
    a, op, b = txt.split()
    a, b = len(a), len(b)
    return '.' * eval(f'{a} {op} {b}')

#2
def calculator(txt):
    import operator

    ops = {
    '+' : operator.add,
    '-' : operator.sub,
    '*' : operator.mul,
    '//' : operator.floordiv,
    }
    l = txt.split(' ')
    return '.'*ops[l[1]](l[0].count('.'),l[2].count('.'))

"""# Задача 326(8) To square(root) or not to square(root)

Write a method, that will get an integer array as parameter and will process every number from this array.

Return a new array with processing every number of the input-array like this:

If the number has an integer square root, take this, otherwise square the number.

Example

[4,3,9,7,2,1] -> [2,9,3,49,4,1]

Notes

The input array will always contain only positive numbers, and will never be empty or null.
"""

#0
from math import sqrt
def square_or_square_root(arr):
    arr_2 = []
    for i in arr:
        if sqrt(i) % 1 == 0:
            arr_2.append(sqrt(i))
        else:
            arr_2.append(i**2)
    return arr_2

#1
def square_or_square_root(arr):
    result = []
    for x in arr:
        root = x**0.5
        if root.is_integer():
            result.append(root)
        else:
            result.append(x*x)
    return result

#2
from math import sqrt

def square_or_square_root(arr):
    return [int(sqrt(a)) if sqrt(a) % 1 == 0 else a ** 2 for a in arr]

#3
import math

def square_or_square_root(arr):
    output = []
    for num in arr:
        sqrt =  math.sqrt(num)
        if sqrt == int(sqrt):
            output.append(sqrt)
        else:
            output.append(num ** 2)
    return output
    pass

"""# Задача 327(8) Check same case

Write a function that will check if two given characters are the same case.

If either of the characters is not a letter, return -1

If both characters are the same case, return 1

If both characters are letters, but not the same case, return 0

Examples

'a' and 'g' returns 1

'A' and 'C' returns 1

'b' and 'G' returns 0

'B' and 'g' returns 0

'0' and '?' returns -1
"""

#0
def same_case(a, b): 
    if a.isalpha() and b.isalpha():
        if (a.islower() and b.islower()) or (a.isupper() and b.isupper()):
            return 1
        else:
            return 0
    else:
        return -1

#1
def same_case(a, b):
    return a.isupper() == b.isupper() if a.isalpha() and b.isalpha() else -1

#2
def same_case(a, b):
    if a.isalpha() and b.isalpha():
        if a.islower() == b.islower():
            return 1
        else:
            return 0
    else:
        return -1

"""Задача 328(7) Filter unused digits

Given a varying number of integer arguments, return the digits that are not present in any of them.

Example:

[12, 34, 56, 78]  =>  "09"

[2015, 8, 26]     =>  "3479"

Note: the digits in the resulting string should be sorted.
"""

#0
def unused_digits(*numbers):
    s = ''
    for i in numbers:
        s += str(i)
        
    num = '0123456789'
    
    st = ''
    
    for i in num:
        if i not in s:
            st += i
    
    return st

#1
def unused_digits(*args):
    return "".join(number for number in "0123456789" if number not in str(args))

#2
def unused_digits(*l):
    digits_set = set(list("0123456789"))
    test_set = set("".join(str(i) for i in l))
    d = digits_set.difference(test_set)
    r = "".join(sorted(d))
    return r

#3
def unused_digits(*args):
    s =  ''.join(map(str,args))
    return ''.join(str(i) for i in range(0,10) if str(i) not in s)

"""# Задача 328(7) Fibonacci

Create function fib that returns n'th element of Fibonacci sequence (classic programming task).
"""

#0
def fibonacci(n: int) -> int:
    f1 = 1
    f2 = 1
    f_sum = 0
    i = 0
    if n == 1 or n == 2:
        return 1
    while i < n -2:
        f_sum = f1 + f2
        f1 = f2
        f2 = f_sum
        i += 1
    return f_sum

#1
def fibonacci(n: int) -> int:
    f1,f2 = 0, 1
    while n-2 > 0:
        f1, f2 = f2, f1 + f2
        n -= 1
    return f2

#2
def fibonacci(n: int) -> int:
    x, y = 0, 1
    for i in range(n):
        x, y = y, y + x
    return x

#3
def fibonacci(n: int) -> int:
    res = [0, 1]
    for i in range(2, n+1):
        res.append(res[i-2] + res[i-1])
    return res[n]
  
#4
f=fibonacci=lambda n,a=0,b=1:n and f(n-1,b,a+b)or a

"""# Задача 329(7) Thinkful - List Drills: Longest word

Complete the function that takes one argument, a list of words, and returns the length of the longest word in the list.

For example:

['simple', 'is', 'better', 'than', 'complex'] ==> 7

Do not modify the input list.
"""

#0
def longest(words):
    word = sorted(words, key=len)
    return len(word[-1])  

#1
from functools import reduce

def longest(words):
    word = reduce(lambda x,y: x if len(x)>len(y) else y, words)
    return len(word)

#2
def longest(words):
    return max(map(len, words))

#3
def longest(words):
    return max(len(i) for i in words)

#4
def longest(words):
    return len(max(words, key=len))

#5
longest = lambda w: len(max(w, key = len))

"""# Задача 330(7) Dropcaps

DropCaps means that the first letter of the starting word of the paragraph should be in caps and the remaining lowercase, just like you see in the newspaper.

But for a change, let"s do that for each and every word of the given String. Your task is to capitalize every word that has length greater than 2, leaving smaller words as they are.

*should work also on Leading and Trailing Spaces and caps.

"apple"            => "Apple"

"apple of banana"  => "Apple of Banana"

"one   space"      => "One   Space 

"   space WALK   " => "   Space Walk   " 

Note: you will be provided atleast one word and should take string as input and return string as output.
"""

#0
def drop_cap(str_):
    s = []
    lst = str_.split(" ")
    for i in lst:
        if len(i)>2:
            s.append(i.title())
        else:
            s.append(i)
    return " ".join(s)

#1
def drop_cap(str_):
    return " ".join([i.title() if len(i)>2 else i for i in str_.split(" ")])

"""# Задача 331(7) String Merge!

Given two words and a letter, return a single word that's a combination of both words, merged at the point where the given letter first appears in each word. The returned word should have the beginning of the first word and the ending of the second, with the dividing letter in the middle. You can assume both words will contain the dividing letter.

Examples

("hello", "world", "l")       ==>  "held"

("coding", "anywhere", "n")   ==>  "codinywhere"

("jason", "samson", "s")      ==>  "jasamson"

("wonderful", "people", "e")  ==>  "wondeople"
"""

#0
def string_merge(s1, s2, l):
    return s1.partition(l)[0] + l + s2.partition(l)[-1]

#1
def StringMerge(string1, string2, letter):
    return string1[:string1.index(letter)] + string2[string2.index(letter):]

#2
string_merge=lambda str1,str2,letter : str1[ : str1.find(letter)] + str2[str2.find(letter) : ]

#3
def StringMerge(s1, s2, l):
    return s1.split(l)[0] + l + s2.split(l, 1)[1]

#4
def string_merge(str1, str2, l):
    i = str1.find(l)
    j = str2.find(l)
    return str1[:i] + str2[j:]

"""# Задача 332(7) Sum up the random string

Given a random string consisting of numbers, letters, symbols, you need to sum up the numbers in the string.

Note:

Consecutive integers should be treated as a single number. eg, 2015 should be treated as a single number 2015, NOT four numbers
All the numbers should be treaded as positive integer. eg, 11-14 should be treated as two numbers 11 and 14. Same as 3.14, should be treated as two numbers 3 and 14
If no number was given in the string, it should return 0
Example:

str = "In 2015, I want to know how much does iPhone 6+ cost?"
The numbers are 2015, 6

Sum is 2021
"""

#0
def sum_from_string(strng):
    s = ''
    for i in strng:
        if i.isdigit():
            s += i
        else:
            s += " "
    return sum(map(int,[i for i in s.strip().split(" ") if i!='']))

#1
def sum_from_string(strng):
    s = "".join([i if i.isdigit() else " " for i in strng])
    return sum(map(int,[i for i in s.strip().split(" ") if i!='']))

#2
import re
def sum_from_string(string):
    d = re.findall("\d+",string)
    return sum(int(i) for i in d)

#3
def sum_from_string(s):
    return sum(map(int, "".join(c if c.isdigit() else " " for c in s).split()))

#4
import re
def sum_from_string(str_):
    return sum(map(int, re.findall(r'\d+', str_)))

#5
from itertools import groupby

def sum_from_string(string):
  return sum(int(''.join(gp)) for b, gp in groupby(string, key = str.isdigit) if b)
  
#6
import re
def sum_from_string(string):
    return sum(int(m.group(0)) for m in re.finditer(r'\d+', string))

"""# Задача 333(7) Nth Root of a Number

Given two numbers x and n, calculate the (positive) nth root of x; this means that being r = result, r^n = x

Examples

x = 4     n = 2  -->  2    # the square root of 4 is 2     2^2 = 4

x = 8     n = 3  -->  2    # the cube root of 8 is 2       2^3 = 8

x = 256   n = 4  -->  4    # the 4th root of 256 is 4      4^4 = 256

x = 9     n = 2  -->  3    # the square root of 9 is 3     3^2 = 9

x = 6.25  n = 2  -->  2.5  #                             2.5^2 = 6.25

Notes:

4 <= x < 10 ^ 20

4 <= n <= 50

Good luck!
"""

#0
def root(x, n):
    return pow(x, (1/n))

#1
def root(x,n):
    return x**(1/n)

#2
root = lambda x,n: pow(x, n**-1)

#3
root = lambda x,n: x**(n**-1)

"""# Задача 334(7) Turn with a Compass

You have an 8-wind compass, like this:

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQUAAAEACAYAAAC6W2MiAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAHf8SURBVHhe7d0JtHZJVR/8QzcaMCKIEFQURAjQSERARcEBECIdZFCZbXGFwaCCoo0yuBBRbBNRkqCARGERowYCKNAE0RhBkAgyySCTNqAIYpCxbdTQcL/zK/p/v/0W9Uz3ne5z32ev9b/nuXVq2FW1a1fVruFcbpqmvRk72tGOdtTorMueO9rRjnbUaKcUdrSjHR1DO6Wwox3t6BjaKYUd7WhHx9BOKexoRzs6hnZKYUc72tExtFMKO9rRjo6hnVLY0TF0uctdrmFHZy7tlMKOdrSjY2i3o/EMob73r//7fdZZZ02f+tSnGpD/e+LG7//7f/9v3/+Ojh7tlMKOGqXBp6FHaZx99tnTJz7xifab297e3v47v3d09GinFM5Quu51rzs9+MEPnj7+8Y9P//iP/zi97W1vm57znOfsN/jQj/7oj05XvvKVp3e/+93T1a9+9enzPu/zpl/+5V+e3vWud+0riR0dPVKrO5xhuNKVrrR3z3vec++v//qv9+bpwNy29/Ye+MAH7s0jhmPwr/7Vv9r7L//lv+x98pOf3HvZy162d+tb37qFnRXCMN4djgSGjjucIfimb/qmvXmk0JQCuutd77o3Txn2PuuzPqu995tyeOtb37p3+9vf/jPC73D0sFt9OMNp7v2nP/mTP2m/2Q6e8YxnTDe/+c3b78/+7M/etzX8xV/8xfSxj32s+dvR0aadUjjDSYP/m7/5m+miiy5q9gH2g+c+97nTOeec01YZvJ+nDtM8cmhKYkdHn3ZK4Qwnjf7yl7/89MM//MPT8573vOb2JV/yJe2356WXXtrcrEr80z/9U/u9o6NNO6VwhlP2Jpgu3POe95ze8IY3NPfrX//60wtf+MLpC77gC9r/liaNFnZ09GmnFHZ0DH3Hd3xHW240lbjJTW4yXXjhhc2d0tgphTODdkphR8eQ/Qj3uMc9posvvrgphq/92q9t+xeucpWr7G9i2tHRpp1S2NExZDTwmte8Zvr2b//2Zmj81Cc/1UYPt7rVrXY2hTOEdkrhDKZMB4wI2AxQRgN/9Ed/NN3//vefLnfW5ZpiQHY+7ujo004pnMEUBXDNa15z+vIv//KmJOohp9/8zd+cfvAHf7ApBn6zErGjo0/DXU07HH1c73rX2/ve7/3eeaCwt/cXf/EXe3e72932vvALv7C9s4txVhJtR+NjH/vY5uf617/+Z8Sxw9HD7kDUGUamCTYjofve977Tta997ekDH/hA27lo+fEP//AP29Qh/mZd0N6dd95504te9KLmd0dHm3ZK4Qwlm5Yq5f86fagKZEdnDu1sCjs6howKrnjFK7ZRA4WQsw+9EtnR0aWdUtjRMWS6cMMb3nC67W1vu68QQjvFcGbQTins6BiiFL7qq76qbVrKFugdnVm0UwpnKGn8EMr/Rgc3velNp1ve8pbNplD97OjMoJ1S2NExZGRwnetcZ7rBDW4wVBo7Ovq0Uwo7OobYDb7sy75susqVrzJ96Zd+aXPbKYMzi3ZKYUfHEIVw4xvfeHr/375/+vCHP3yZ647OJNophS0n8/76zAoB20CIm/e2Mbs9KX5Rzj/wY0RgM5ODUH/2Z392zPVr/UoE8r/wwe5mpqNBO6Ww5ZShfb/JqA75/WYrcHbBGQa/NXKgAP7ZP/tn0+d8zuc0v+5ndBMTpRBF4B0/VSnkd+KEXN9W/e1o+0jt7SaMW04a72jpUON02Oka17hGMx56NnvBVa4yfeEXfuH0+Z//+dMVrnCF9vvlL3v5dN53nzf92q/92nTPe9xzus933Wd6z3veM732ta+dHvawh7WDUf5HH/zgB6f3v//904c+9KHpve99b/vtjsf3ve9909/+7d/uK54dbSftlMIRoc/93M9tQ389vZWDr/iKr2hPSiFDe8qjkhEExaEBP/GJT2z3NL7uda9rS5I3utGN2gYmV7Ld4ha3mJ75zGceMwLISISb31EElMSf//mft4/LvPnNb27xRVlsSol7R6eWdkrhEJNGrFEYzhum1wbiS01f93Vf1/YTuADFhqOrXe1ql739NPW9dW3USHx7n9qbzr782dO9733vpgD+7//9v82dknnCE57QDkhp2H/5l3+5H6ZSH2dP/LvFyd2PLm95yUteMr3yla885mBVpimelAsyXTEdQX2aOzr5pMTPGMyCN3Q/rMDv2Wef3X7f8IY33HvIQx6y94IXvGBvbrx7c6NvX25CeaK4X/qJS9vT/yPinnf/8l/+y/Y1KPTHf/zHe/PIYu+5z33u3qMf/eiW/tyI27uEqWFXUe/vIx/5yN7//t//e+8Rj3jE3td+7dfuzQpg/+Mzs3LYz3f+j9sOpwxDxyMNQnblK19575u/+ZuH708n0jhAY5xHAns/8zM/szfP7ff+4R/+4TMa2D/90z+1hl8bfxps77envH//+9/f0nvQgx7UPiH31Kc+taX9B3/wB3vPf/7z27tXvOIV+2msGz+KYgK/Afk/5C6Hefqyd8c73nHvcz7nc/bzD1EKO8VwSjF0PNLQC+ltf+iHfmj4/nSC8H/FV3xFUwRvf/vbW6OpjS+/07jqu9rQ1qGE1eCl7ZuR3CgHZTRPHfbe/e53t3e/+Iu/2Px6X7EO4SvKq4aJouAW3n3b8slPfnJThnioSmGnGE4NzoglyVmYGqzPe37DN3zDNPe6zSKfNXbup4rwEUh3Fv627Pdd3/Vd0zysnt70pjdNj3rUo6Z5SN/sAnNb2Uf4ZAdA+d878XgmTKVPXvrJNkfPe4idwvIjmqcPLT7ps2Pg74u+6IvaO/YA5L5GYfgDl7mKV/ziRN4H7f9Pfdougr/2/2XvhD/r7E+7+c2NYfT7vu/7ppe+9KVt5WNW3G21JO+TLsLf6aSv/uqvbrYdVPk6CnSMljiqmCuszZOvfe1rt9+zQO390i/90t6sGNqQndso3MlC0rvGNa7R5u1/+Zd/Ocv8sT1/etHq1lN9Pxop5H31h9J7c5uVUePnwx/+cEvzi7/4ixtvb3zjG9v7G9/4xs3ekJ6+xhNKr7+KEn4Rwpe4Et/f/u3ftukFmwo+jSCCU11vEHk577zz9p7xjGc0WQo/I//bBqrNjyNLc+Xt9zDz8Hiapw3Nys7t277t29rdAT//8z/f3s+VespuGrJa8CM/8iPT3e52t3apCav7WZc7q40A5saxvyqwiuQDJZ8gH+jv//7v23KgZUIfiPX7He94R9tfYG+B/QbS8t7W5j99/Z9Ob3v729qIQc8+T1/aaOr7v//7p6c+9altPwPKPoerXvWqbTRjNOHiV8/rXe96beWileU8epAHPBlhXPrJS1fueqz5QMrl8mdfvv0W1+/+7u9OP/dzPze9/OUv/3SZzenIw+kg19k9/WlPn+5173u1b2MYcfarRNtKTTscVcxC1kYI/+N//I/W88zD4L1v/dZv3X9vtKC39pvGj/vJwtd93dc14x2DXnrHUHrH9JDrkJ4V+Zw8G4Se6/zzz9/7xm/8xr0v/dIvXdiLKRdPZeO30YJ0f+3Xfq39/wVf8AV7f/VXf9XiZk/gNhpRJf78L9zNb37zvXkKsPekJz1p79WvfvXexz72sX0+k+dF6CnhQsoNrJDMSr2l3fN0MqG85HlWgs1AiowYvOvLYosxdNxqEBK4whWu0P5n1X7CE57QBCmC9+Y3v3nvDne4w9797ne/1iD4U6kJe1CEB8KhEaUhMR7+99/87ysbAco7jbT+rspCY3nrW9+69yu/8iuNf0NraSX9Hj2fgTx7P4+WWrwPfvCDm/s8t2/LnojBcVU8i4CnL/mSL9m7+93v3urg9a9//f4qCiAKLb9DvWLs34eskHzTN31TSysNMvU44jf5OAhSVm7BftrTntaWbNUD+eL++Z//+XvzKOmYMFuKoeORwJWudKXW8P2OwGiY1shjDf/4xz++97/+1/9q706EUojgJL55qL33n/7Tf2oNAaUxBKsoIwrk+apXvWrvkY985N5Xf/VXD5VA5WXk1gOPer95WN7SSHlRMuH5Pe95T8vHqrhGSJjaYCnIH/7hH957yUte0spfPfQjArRu+VAgv/3bv932WvRpVV6A+0GQsNe61rVaWuwu//E//sfGw61udav2TpnZe+G3ugkfW4ih41YjjcXS1ote9KL2fxoroX/gAx+493mf93l7F1xwwd7f/M3fNOG7053u9BkCdFBIz4YcvS4jWSiGvYqeNI4oLNCLGuE87GEPa42pFzT/10aQhlD9QM9jhd7NUiAi9PzbVIQ0OHx8/dd//cp4RlAWnsLiM+6Jy3cmvud7vmfvxS9+8d5HP/rRfeWQ/MOonEKUQp6mKf/hP/yHNoURvzpIejXdTYHHm9zkJk3p/Pqv/3ozuipnU1JkusSfkakpnClpZHBLMXTcaqj8pz/96U2gCQthMy9WeXpFw1hDPX5VpF5LA07Y44E4KJ53vOMd+wJdBb0qhJGwx4/9AfYqXPe61z0m7iBKLu79+yBhF0FD1cNJF8/KRzhDckQpIdOsdeIbofID4T0NJ/+z7aiL173udfvlg69gVF5xq+8ouEX8ctsU+CQfl1xySRsVRAn/3u/9XktP+XEzIpQuew7b0UHTOwQYOm4dUgF6h3vd6157t7vd7VrjZHj70Ic+tC9ght8MfUYLtedK+Pr/CAQkQhFhzm+KxlwzNBLiSr2gGyG87GUv2/vu7/7ufXtIn37SWxd9+B78+DIUBfq85z1v381uz/DknSXBdeJbhfAVjN5TTLe97W3bnD0jgdRfLS98+b+CH+T3S1/60mYQFG8MhOLfpBcPT8L82I/9WCsX8ZABRmvExvALv/ALe//23/7b5t87o7rHPOYx+2lGZrYEQ8etQm2cF1544d5973vf/QbvybbwHd/+HXsvfOEL2zyZoNk2TFD42QTiqxUdJXGXu9xlfwhOWCECuoo0vGc/+9n7vZB0xC/uPv3kc1304Xvw87jHPa7x8eM//uP7blEKaWxsDn3Yg6DyNgKlXstAL2waaLSHlGkt1/AXIKMbZZrfdq6KL4qhyss6wI+naZbpVf7/0z/905bOs571rLYCkbi9/87v/M6WPrtDjWNLMHTcSnz/93//3nOe85y9pzzlKa2nJWC9ANi8ZMnuTW96U2uEVWDXQeJJvFe72tXaCkAlCmFEhDYKIzCS0askbsJDGaQ3W5T+uujD9+CH4QxvFGeEtyoFxPYir6M4NkHlbQTlGn9RuGB5lQ2oHszKqkVFKKOKTH8M9dkExEU2Us59+iNUvitPZAjd8573bP87t+GpHCkLHRDZ8L1OYTM12wIMHbcGKkxF0eKElptKcqiHUoi/VEgas3cHGSlEKMRh3m0nYt9zLVIKyHsC81//63/d/2CreD0rInhQ0+/9rUINO4Jy+LM/+7PGcxqNcFEKNS8MbD0/m6Lnb4SaRtzyP6v/z/7sz7YpoRFflEEQSp3gP78ZIk3NxN93FptAWIZqIwUGam6Z7pE9aVJGprHSusc97tFGYTWOQ46h41ZAo+4FKNrfcN7ae4aMNZwwnsLU8CPwlzjTw3C3LDhq/AQz7lUwI7TW/C0nJu6aVtwqRu/q/57yV5VVBTd8m1tr6GwpviL9zGc+s1nUWdYR5ZaeTpxVKaSxEW5p2eCkbBnfbn/72+/d6EY3alO08JM4wkOtg7yPnx4Jswr2Pvy3//bf9kcEKPaHSin3AP3qr/7qfieBD89N0hZGfrJSkzgohExbfuInfqK5KRdx20/BcJw4DjO2cpvzXCFtO/LcEKbHPOYx05WvfOV28zDMQ7bpkksuaZeC2IZqC7GDRqG5gto21MQxV+jKbanCzALVfkvraU972nTXu9x1uA1ZXPxni2/cbDN+xMMfMf3Wb/9Wc5t76HaYiN/QiI9F75MPlLygWdinc845p21VvtnNbta2U9t67KCRvFZyhbt3Lj558YtfPJ177rn75TGPgpq7dGwnVta2F8/KsJXt3Cj38+i9bdO2SztM5fCUW5cctProRz96WWrHknhzeUylURn0hBfh8Po1X/M1ja9v/MZvbGErv+qslh8SzjsXx3zP93xP45Gf1O8q4jc8+u16O+U4j/qmX37KL0+XO+ty033uc59W/rPSnX7nd35nevKTnzz9xm/8Rvv967/+6y3sYSc53BrQ8HNltOkC2wGKdq6kh4u7DUsJH61en+JbBH5mIWpPw2dDRpRRwIjSIyGbc/79v//3+zvdxJm010HPT/jNO/+zSTjurPe39Tbp156TG6RMLrroohbW/gfuP/VTP9Xi1AOK10iBe+2JGRv5YRRFdfheKWGMPhh+2XDse1B3Ne+py4q8W4XUCeDZCIihV9qG7hmthb/KZzZlsU9k+C+OxLcM/PVpGxWgiy++uBkYucuzTXKZVrBf1XCHHEPHQw2CZdhrQ82/+Bf/oi0DWk67853v3ITc/M1eBPcD2GzyR3/0R22JS7hUjG28LMbcesGsiBATHnPSNCoCNhqueh/hc08Bu0GNJ7/z/ypUXiBu7huwakBJaQQaQxpCKHxw799prHiw7IfMf8XdK4U0IKTR8WP6UUna8g0x7KE+TRt7rOVbKlYPSasi+V6GWpaQ/8mElYBK8lBRKf+TGXGs02gZEefR175C4+Y3IyiDbf639VlHUOt5XcVzCDB03BpEsKwhz8O25paK8IzgBNzSY1Ee/+f//J8mTImPn/yOkDjcsw6lEWgcj3rUo1pc+AsfiXcZEqZ352Y9XI/OMKgh9lQbIYH3f3rtkJELZZbtuEYM+CXo/k/ZMaImbAUlbA+IOPpGj2pafsdPwosTjCLYJW5605vul41nLad1yixhKij7nNtIumikxFOOlFWNM+UAqb95CtAMxPGT97E1kScjBe+qkTv+a5hDjqHj1kBBa+R+s0pblkyjijav4K4CgT9DPCMAG3i873uLrOGjUSMIES6Ny0Eru9mEveIVr7if5iaoSoFw6Z1sA+6FWnoR+FD9n4WegcuymHJxOtTdCDkVypIvDsuNrqervXdGCj0yPL761a/eVitufetb793//vdvW3vnOXOLC8V/FEt1q++QMxA2/rDoH6S8QLhaf4yApjs1/VH9hQfvjJoYBiMf4UV9GuVQNLZQ533Sliaoq8c//vFtlGo0BJW3+N8CDB23Cgo8lagn1ZAJKhtAKiSole23BuJ8AsGxB597lEwOvGR4HgHqKUJnGkMRCHvQniLCxrquN7f1OPGj9NC9gPPDnsCuQAEQZDssky4k756QrcxWRPJulVKIBV0ZySP/4RkMmY06lKWt5kY14Tlx+J3GmgNRiEIxejAiSnx4ye91kfz5bQRZpzSLKOVJ+abnV5caecIbIXGPfCQtzyhUv8mB06B1H0z8bwmGjluHFL7Kectb3rI/fO9R/ccIpJdClINNMgSbQDCOZYPKMoVAaLJBJWkQljSwiqS/CHpgSk0D6RVRdmOmcXlnZOIQECWw6NLT6oanCPUP/MAPtHgoP/6UXfzbv5/GW2GLOD+90gvkO+n6DXhjjGPb6Uc7iRfhBTljYJ+JZdRRGutA+smnxuxy2qRTqbq9973vbcuueL7ZzW62fwYDVXkSZ+q2T1NYZVMNy9XPlmDouLVg2HO/wKjSKiK8+d9cEdkRSVk4mOOqNn7MFSM8vWCZGztolQZQ0wDhe6RHqaAMjHJcfx4ikH0vx82I4Cd/8icXjoSCuNV06v96cmRbeP9+kVIwjE7cCVORNBfBAa+HP/zhTdmKLz00yv+e8mlqQzmkHsQv7dpTr0LCmSox/IpX/D3Ze5FOQtkqd35dSXeLW9yiuVOaiXcRal6T9hZi6Li1ULHLFMKo0gia7c85u6DXN3dkhGRr4Edvl1FDBFnPl9uNFgnMKD3+pem3EQlDJuWSBtE/keUuKyxuG8rwto878a8Dft2KhHIsGsLXIkOjhqqs4r9Hz0+P+FMG7BFWiHKuAUnDiCj5R95rqOqkxlGxyL2OfoyksiU9cRuRMVDLNxuJA2nIiMYIKrtkYaTMeySfwcjPFmDouNVYVhmjSsvT7UBIA9SjERLCYY7ICBZDEoHVs2jQaURppEknqGlBFSyGKHNP8aURgIYRspZuuUtvKUztJfu4Ie8WIX6suBimG5mwq+Bf3PjjJzaFnvB57rnntjiS94rKywjxU594sa7vJinxo0yT0nj9prRtU04Zhle/1wWe2WqQJUR2F25sD+odseOYOnp3m9vcZhjPIiSfwcjPFmDouLVYVRm1wuLP/M9w2f+WnVBuYzIfJZCW7jQUbuecc07rdQ46nDRVoGjS6CL46SERS7dhdrbJrqt0+vc90pCNDpDRgv8TNu8XjRSQ6ZQGWRVc0PNT0fuN//ymdC0nmqKkHJRNfocfdUNpGzFVRVbj7ZG6kj9hrMJ4UrZWPxBFZCQhLoZeex6MTmzjNiLs4xwheQ1GfrYAQ8cjiVpRnoTC01l4c0hWb0KQC0v1KN7nkAsypIyRrTaKVQoiqxKWF7NsFyLsBNLTyMCV7xm2huegxnkQZN4c46rhu/+Vhec6SsGNQ/ycCJ5q3hIXhWsKZ2SgXEJJH/3d3/1dO3uxSFmO0Ps1bcvmLErf1Iw7W406yoiIDce0wu/ITOI4ohg6HklE8CDCb9ianihLcxouAbR/IYeX7HqLPz2ZHZIEpPaYiXMEm35MORJHGlyGyZ4uMrHTMmEon8oz1DgPgsThJirpZtUkeUivm+lDrxgQ20oa2PHylDiCWp5GcKz+vkeB2DPwo6yipI0askoRxbYIFLM0jDIsPYYYmdUPP6YL4tZR+N+N1NJFDmBxC39HGEPHIw2NTcVapUB1iGrI7p17DhBjY3p5c3v+4p/guNCUfyOFkVLwztTkne98ZwuXhlV/20DlxGLCENw8e8TPQZERDUs80vjFm0aOX89FSgHf5t42B50InhJHBR5qWRrKU6jSRuErZNRgKVHehO/jz2/xPuABD9hf7rUEyZCctExdxO0CHm7/+l//6/08Z8Riudi7lFfiPmIYOh55mFMztPWk8m29tcPPsBFRBgmX3j7DTsYxjd67kZA89KEPbVMTYdLTRbgZ+WzyEU4vNxI0/1fUdweBhiFv9mTIAyOjeJN2lJuVAZQG6AnKB9haxHe8PCVfFWl0AX/4tiMzdYIX5YmXlKmRFn81/oQ3ArPcHIq9wDtpGjEiceYuT4ociTtpSJdiES4KVnjPI4Sh45FAhKx3N1S0BIgi7AFyezJ/DkEhgpIeVYPKdejZQ0BgbLGuAskm4DBWKD1NBMwmoKy/VyR8sOr9QWDOLK82efXxj5RCRfJhOjWK+0QDT/gJf0ZmtlSj7CXwjKI16rJqVOMwiogdxyYmu125R2FQ+uJB9opIx/6IRWQXpiVqYcNf0joiGDoeKai4aHU9ANsBiubvQfAddxbG3Fsjdhox3z6wVJU1/ggjMuyMsHjWq8PyNDqoux97cK9Y9f4gyLTJSksf/yqlAMiI6VQ1hvBW03MKMftKomijsCxb8mM/BcWcXt7ZhqwiUOBWdhyr9x6ZKpKPellKT/yCUYRpDZ7wFr6OCIaORwbpvQm7ytMrIAI0EnhAbucRjiKgEAgCBZH4CByLdU+EyV4G6QmbuwcIpdt/9WLisAoQYa8I38Gq9weB8wXyyX7Sx79KKYSylHkqUfOPR8N/I67wpVFbPvTeUXA2A+SZIX9WX4zk6rZrU6l8v8H272WkLsEBMEokfNWR4pZj6HikkEpzRVsv3Chucc+hmFS4qUN6Dj1UeiyXmzByCRfh8pvAGDVkG7ILUKx/RyDFW3mriPu67zeFODL9YUjr41+lFNKrGgXFYn+qgb/w6UnJUfb4t2JhFJP60HCz6zRLyaZt2WZtKoDsvfBOfPw6TzKi5F/8fls+Dk/h7whg6HhkkIZt15zPn1UBD6nc/P/nf/7nTdiFiyB5Ejxkt5vNRxECy5eUQBpMD3c59jylR1lHkGqDhZGfTUAx+dAMqh+aCfDmmdWHHvIUcgpwlMbJRC2zKNmAklM/yAqJ8ysauXee8mU0EDmI4rAHQbzeJ371bhQiv9VvT9yVlTDCh5ctx9DxyCCVrcdIBVegNGq7CLM02DdYG2qcmhNHphb8gDn6IsWADLUdqgkvUQrrgP+KkZ9NYIMW0nhG+yBWKQUkryhf1TpdSDmaRhiJpeHaoVivzY/fu971rs2mk7zIByOl1aa+vvnP1DEUw3JPppH1jMQRwNDxSEGPgTTSKuBQKbfmEIheSMAVaKYRhI8i4JYhqb3z3o2UArL8mS8GVWFdBX4rRn42gSkUYnTzfx9/+FumFFKOUY6nAj2fwN3SaA6TsQuwB6g7+fA+T1O48M9v6oZ/70dTO6BcsnkqyrBS4nLiNKOSI4Ch45EBw5OhZAQiwh3BjvZnRCRMhCJDzRpP3KxKCGcIahrhXQTJUpl4KxAlEpuElQ/Ddv5HiqdHbQQ9TweBOTD+KSj/9/GvoxRCDHWJV5j8PplQZtKijOsFKK985SvbeQZ+ko9MHU3h1EGtD8R2FP955jekLCxpCtvnH9V6zu1dCb/FGDpuLSI0fnv6MlCv4QkFtzRUa9sEIA1/GfQoOUJte2zSSwOv22dHJG1HgRcNvfv0eozCLEL8e8ofZANPrlWrccef5yKlAPLgaQNUFGPCJe0TgcqX8g1MxZwuRRqk26AoAO/SW+PHk6JO/eeJd6OKTDESf35XHoCbUVHkBUURIPEh+z7sY6nhajxbhKHjViOVYRkK1QpE/o+AWD1ID5Owy8CPaUSs1v1GGNZvS2MoPdKI8ECBsIRH2NdNf1OkgVBodmDKe5bu+vjXUQrCe8pf9mWcDKUAtWyUrZFOrnCjGOomokzlgA3IwS3+8Jm6yPMhD3nIMfEn/wnfQ9r5oOyIlAdyAax4xJly30IMHbcetu/mRt8ogErcCIj97gkTwViGCJ41fgJnh1w+/5aGwejkmrRllF6HgPsAqvBVOBchvG6C9J4ODsm3OXjy0ce/SimEohjcBymek6UUKDLl4n4DtyCFD0uQSTMjvNgFjF6imFP3ninzXMWuDIwwljXe5AkP7p7M9nZ131PKx3KuMMviPeQYOm4tVJ6nffCIgS+CVEmlGkrzW4XZ72V4wQte0JYhCaJ5LKpfZI59wW43vfIiwk8E1m+rI8LUtEYIn+tCmDSe7D1ww7N3ca+I2yqlkB7XUm3SgZr2iYKTkhmZWTVxQpW79NQ3pNwtJ7/qVa9qftVxeMav8s6lMr5mbSmSIonSXARlkgbuBiiUEUhP3JXvySqLU4Sh49aCgJhzqhxCUBtent6Z1+s5I8yrIG7GOeRQDkGyfEkwgBU7DSoCZNNMPt66iNLYIKf9hI2QV1Re1oXyiNBnFcYV5P5PD1uxrlIIWf6LIj4oUl41HrxZPs2WdOST9OnZ8VjD+t/SpHMrylsdI3WT38iXpKTzwhe+sOXHaVhxcKvTjyDlElAilqYTb40bidO7rE6N6nELMHTcarzoRS9qFVQNQ0iFcVNpGfb2ld4jw1dLeQRAWMTwxN0cF2nQ2eNAyNIQKR4GqFGDCnkXIMNb4cQB0kl84cvvdcCvsHhy1kH+czaAwCa+IA1uXaXgQhrzbWH6tNdBGmTSjhsFlqVAIy5f/8q7GoabZ0YIUcBprHhOnWUZVt1zj3y4TEd83vUQdwU3I66ElU4tlygKm+Dsc0iYLcPQcWvBqh4hqD10hFqFZfjcV/gI/GmgOdwUshTmdiLCZPVC3HrNNN4Ir9+mBRTDshEDqsKlQbgdSXjQi0VwK2+rUMNk1SRfZUrDqsCz57pKQXmaay9qVOtAegnPPpPLU8XtZigWfe/DW/gE7v2UAUJ41oDZftzozN5jClH9qRdfz+75gqQXpOfPN0H69FDq2aqIMPwfT/mcBgwdtxaZ5/cCHKFWgTn4kgYc9AKQCtXYhRM+dzBY6iSU4hBfLv00cqi9eoTI3gSKYR0iVOFX72YOLA7xRrgqf8sQ/7mo1YjGKc+8TzzBpkoBOXyURpt410Uat9+WaVO+RiAZHUD4y29hlK0pQxTCoh2HiEE5cbhNCVUlbTQyWk5MmAru0qVoUGSjkrh1JNmTou4SdgswdNwqRKhyJHgRqTjzaZWzSIBrxfntoAxSyREix2Y1VBWdRm9Iml4jl67URsyfhplViTT8ntL4AuQugLqvoCqdyu8I0ucHT3hz41LejcKG32V3NPZkQ5cwi8p0GaTHdkDJhlx7lv0PIyQdvb4t5PhSnvgdkePR8iqc9CxXGo0IJ0zqwq5E/moD9uyROs89l5GLEUXehPFMHg45ho5bCScTlxHNbiowClsRoTPMdk9jKI0k3wiMcBA0iC1Dz5Ur3LgTsjRkDaBuvOlJ/BUEzvDXb+vuGTVAhDT/jyB9fuzZkJ7NPNzDTw/+PTdRCu5JTDp9fCPwmzJ281SmZpQfQ2vejeKLGwVrVBgeM2UMpWyNOEwv+vD2psRmwa/w4nE+gp9FqPn0pJSEXaQYpGEvSk17CzB03BqkYfqgx4hUdARk3WOuEUrbeJEKNzT1dMNSbeTiitXafNhHXQmJ3tO7pOUZXgl0vrHYUxpfgCJw/nexiCVR8UVQlwlb/OkFhaccKl8j/56bKAX7HrJHYBWULX7cR+Fz+KkbCk+5pIxglC/lbuieDkDZpEGHagPNx3xqefnf05exkn7qwuGmTCPivyLu+BRnPY6/qHwcw15U3ocUQ8etgkqyWSUVXEllc9djZC7N/6pKygGaVDRBs6ON8EcJEFBCHoHjll2Uenfzcu5RMvwlXb3HyMZQBSxp51nnzJbSYvVP2iOEN+UjnlXHncPfukqBH2XTX4G2jCc3G+WjvnpSowVlKUyUbTWsVqhD9SBsdjaGwl/4ZqSsceS3dFKH9d7GxOVMhXcaPr89Ek94rVOfERkJuSNylJ9DiqHjVsGFnio0wlCBPF3MmV6qoo+Lm9WC3OkXpSIODar2ZCq5j08a1sCFMRogxL0wRJgYoSxd9elU3kfknYZI0TklKN0IedKqTz2rfRmMoebh/Hs3QsKtqxTwwd3XtWr4mkbKhZ0gN1Eh27xzpX38JEwNGyjL2AJGxF05UsjKpj/OLI76PxixmFYmr4jytaKCH/mBykcfjzpYRvixAauGOeQYOm4NVJxvLCICoWIrkF1wEZBllZv3Lu1MWALityFghKT67cGPTUu5GJalm98ogh78xvhoC234Tvo95R0hBuQuAQ0mQ9o+LasjGi9bB/7Ca/UTJH/rKoWUuQtPhavxJi2/GUqdLBWn7ec+xBJ/+F3ET8AukNEOkp8R4cc7U6xRPCPY0JTyTJlmV+IqpZDfdrqOCC/itLrh04MJd8gxdNwa2BMfwUQR3gDl5mG96aLKDeyGDEVAfPwlU49gkXKIAMUyjbK0lkabMGkMFENuDOp5r8QNT/Vd3CghBlANUTq1oZk78+dUZxRb3vUIf5sqBb1+8pS4pKUh5IveyPJub+wNL/xXdxCfTUC54AZpaDDihzv7SR/PMsjzS1/60hZenEnHapZ3Ka+KhA3PRquLCE/INCnhDjmGjluD3LYcoe1hXd6mFX77iq2VG2R4K87st2fE7P3W/2t8kIaXm4Jdf5aRShUy/2c6YhhL+VTe16Xq1xJYphIRWG4E80d+5EdaI6vp9/DOcxObAjLayYpLoKEYHSCjILsU8y7lkLKq4SoY/bJTMYeRUHjpecotSIvy14M/ZeK0ZYiiQ2wX4ZO/ioTHP3DLB3ZGhE9nZGrahxhDx0OLCJCKJDCjexcJUCpWg0il9XEF6d00hGj19IB6EO+Fj79lqOmwGbhJWFx6y+ovwuZ34uWfHQLV/GxKhqrVoOj8gHy5wzCNcFF5hKd1lQI3/sybY2xUL6ZNCWMVx/JuTSfARwUlGd6MECw74j310pP4U9dIHoWVz5rOMiS9pzzlKS0O+RGnPBnxKZPUUeU1iHzkC1PC17LL/1CPmif9Q4ih46FGziMwbqXgg0p6ltyVEGHvUSvcPgPCEIjPiTzv42cVCEf9P4IChvHcwkuEqvr3ObZsRyaUmxLBQ2whTjAyMuo9ua/znYLwtq5SqMQ459ubOR2Kh5/4iZ9YWnYpg1oWnrEhRBksSpt78mwPhsa2qhPoEb+UsiXlml9KmrzVKVlF4pAmZVi/YJUn4BGyPLlTCicYKVCNOIUeVMoBmAh6niPY8ReKQnAwSRioArAuEiZfijJqSMMML/HjSejkjUXeVOJ4SB6QntZoSnziX5WX8LWpUmATqaMDF55SEtJa1gC8r+BGIWS7OqWwLN0oDelnf0GmZOtCusm374OKMx0DcoCMn4xiKhJHwlOC+K3LxykTYPvxEZqEO6QYOh5apPANVXtrPUQj62VtLFFxhLJWYEXis3lG+CgEsM/Au4RdFMcI/CZum3Iyt7YuHuHK+/o79gA2hlUXtYxI3kNp1EgjS08n/kXIe0oyDbJiESk3Za4x2OCVhplRwiLFIL0KU4bMzWvDQiMe8n92mYb//vcqRGHaP2K0gDJSs2txpBASf+oOyGXOwUQWw2P4Z3gWZlPldQoxdDy0iJD5cOuI0nPQyPa4jyqyQuXo0SIACe/Of+nwU9PfFKl4G3YiJM5JaCRVmPxOWgnDSp99DAeZSqA0bKSxWa2JQEKUUBAelikFeUD5H/ltqJ0NW1FAq4CXlIN9DHgU/yi/0kjaeAP/uwKtxtPnZVPkgp6MFNC3fdu3tXeV9z5ckO3uwuMvZRc425G8H5THk4yh46FFCtF++xERJpVRDYzLIK4cg42Qodvc5jbHpHs8iLDmdJ4dbm7+4RYeep4CPVfOSuDvIFTD+Z2eXFrpweuT+7qnJLkpb/aLKOFR41wE7/mPDUH518a4iNLYlI2dnenpa7oHAZ7Ujd4eH8pLOvXm58p7DzxYrUo+Um4VdnPmDMuieE4zho6HGs4YLBIclaEifWqe31qJIzDE2b2YCkNu71G5J0LIQDristchhqgqZPFX0+SeEYOphHCVx01ImAh3FIRlvlzeWvOZ38tsCiljxKjIGCuchpmRXJByXgT+TRmcZRB/Rgij+vVe2hCivCmyPt2DIvH49BxKPj1dolN578MCXiyJaviolh2IB//11GsfxyHA0PHQQqXlA6AjwVHgjFzxXysxFVD/t6Ek4cxhPXO5SW0sB0XSDAxDQ6ZA1U94km7SjpBSDM5K1AaxKUXAEQFVftnYFR42GSm4Hi1Gs/CceILkaREoZQoq5V+p8htKo0LOKIgjytPvmvZBkHKXf+UjrcjZ4x73uGN478OC8MowSqUvP0pPnPmQzong+SRg6HioYVVAAY+UArLlNoVdK7FWQCrfrUkELcJm+c4uPH4jbCcS0s1HYxzLtoSn4ROkkX+IYmBjMGIQtjaO4yXzeB/DlUbybKSARnN7m7GyS3NR+Qb9+5S733rUKISRAhiReueX8S9L0+Lq0z0oxBXFaI9KGjNyj0Zvg+khLDiduYzUo+nWKI5DgKHjoQVBcp0WWiRINu6oGI1J5VaIIw2QpTiNK3GxL1S/JwPykJUFG3vS6NcBxVD3ARwvJe8av28haGSgDFEaBT+eeji9O15quS4qs/59GpUpQz3ZuomCwyullfhreicC8q9OlAdKGUGvDEdhPZVRbmZaRNnIdAgxdDy0yPA7gtyTBsPwlB5khFScbzcgcUUoY4uIIa6mfSKRk53IteFRVD3Cg2eUHONjbBPHS8m7URfY/WhKkH0buR7NHguHjFJ+dcheUXkfvacUKMXc0pz00xuvQ27VxkPq8WRAfdgen0t28Ime9rSntfeLRpHCRfbqidCQvEZufX804fiv8ZxmDB0PLVxeghRuGlWlHIaJwFSBrAWvUgmmONLjskWcTEEL0ltaSouQ+OpU7y+ovGdUUY9dH5QyCsBDGqXfGr9PqoXsrbDpisBH6FeVb9C/NzXL5TX99C8NbxkxSK4awp8ISEMe07Bzd4P9JtkktUhWuKsnd3L0lHL2tHSZMKOyO40YOh4a9D2oU3aVVBRKYdv6XMP0Qpl3hD6NIb2V3WinqnLCS+4YdAowl6ZkRDAKB8kD46O9AcnHQUi4CnHZ9GVoa1nOpazSwhNhx9cmSMOhhI0QTBnQOgoApW4QfuyzSDmcDOA5T2AbkD6EZ+cr8n6E5NlUbzSaTVlbmj6kS5NDx0OFFLICVJAKVO+ukqpw2eHo7AC/CjmNqyLC7ebgWtHoZAvcCObuOf3nxCceuSfPI9R38lsvg92UIqCBMqEIKCj3SUojPFFGtSzXgfIWVu9KAaI08nUp+fL16OT7ZKHn34aquryIcs/lsvLwXt5TNynbUMo7n5hLmEOCoeOhQnpGGroKvkKGDEMdde3D9pWVuPoVDIeQTlfFOCSD8MLWgEcNf8RP+Pc+v93HkKlEBHddinAGKB/NlX5sKweFhsFG0Y8Q1lVgWSY25VimKE8Uev65ZYcinpVRppnKv/cfhFcX9iAjBuF7xZAbmVKXhwFnzX+2guaCnuYh/3TW2WdNn7z0k9NcptNc8A1zgU5zAU/zfLP9jjv0xN/ca03z8LjFGbff//3f3///VJI0H/vYx06zoE1nXe6s6Rd+4Remq1zlKu3d5S9/+fasVPM7C1j7f57nTne4wx2md7zjHZf5Ojgp20svvbT9nhv09IlPfKKVdbAp4fMFL3hBK29xn335s5u7p/9X0Ty3n+b5/PSDP/iDLa7TQb/7u7/beL3cWZdr9XWDG9xguv71r3/Z22Mp5TQr0/b/61//+vbklrwnH+K64Q1v2H4fNvoMTXHYkCGoQ0vLKDflzIW9FHVjjt6Z9jaPrmnGb3U7mTCHz6UuuXA0PVH8jPjhlvKxxMrGkB7toHS/+92vxSfelENQ04ZF7/FvWU4Pjxdl3PeSIx75ibve1e9cznIqDIx9ftSBnZ/hi7x41g1ufZgKuyArpRzEAepLGomr8nIaMXQ8VEjjWHZqUEHnc2iBsPX/uFkK4j9TB/seWNern/r7VMFQMmT/PLfKw4ifnk/LlcdjY0DHoxSyVMeGYLs4wUfKO5QGsYzy3tBd/afx9emfaPT5ka48+Qw+Sj5yaY73yxSDqZPDeWQtyroisieuKIdDgKHjoYGC9XT8uF7HFUolWSqqV54nXP0/bj77LlyWIi1Nco/y6f2fTBC49BB+u60Yb77v4JBQ5WEZP96lEVuVOKiNAR2PUoCcdkTyAuEjjWERRVEjewRckiNOaZ2KRtPnJWm6Uh8ZvcgPJRG+likFcA1bKPmv5eA2aHEcFqVw6G0Kc2G155d92ZdNV7jCFdrvSpn/vvOd72xzz9Bc1pf9OpbEcb3rXe8Ye8PrXve6Nr+rbqeK5kawb8vw+0d/9Efb85rXvOb0xCc+sbmvQ+JQFvIw90zTv/k3/+aE2Bg2pSte8YrTs571rOmWt7xlywfCE/7YJ1DyOyJ2lNga5pHT9Na3vnXftjI3ovY81YT/V7/61fv2Av+zKVzrWte6zMfiPPH/9re/vfE+kknu4jldeRvRoVcKc2/VCpyRcUQEhrDNc7NhwaYiQ5SLBofEjV71qle1J4r/PtxBKcIy9wLtGcXDnRtDWvjmhpd5etMaxj3ucY/pvve9b3NPOSS+niJ0nvzOI4XpW77lW5rCQ+sY9Ua0qjyqO4Xw3Oc+d7rNbW6zz0fyi5KHZfSpT36qGeSe/exnT0960pOaMbWWTy0D5ReFc6Ko5jWQPqVA6aov8uY5j2IuC7WY8PaGN7yh8SmuEX3lV37l/vsTmZeD0qFXChH2NOSe9j6114TtoosuusxlTKlgluOMOCKwb3vb29q7jDqOh/qG4DcQYO8i4NLjHkGj9O5+97tPT3jCE5qfN7zxDU1AHv/4x09f/uVf3sKsIzDi1ZDQPAWZzj333OnlL395W7VJ2ieSwhPl/JznPKetgsxD7JY3vGxKFMLFF1/cVmMe9KAHTd/8zd88zXPuZs2vZYeST2l5rxxPdKNKWuTrwx/+cPttlQipl6S3KK/cjdwQPnvidp3rXKfl7WTUz0FJbg4t5kJrz9xz2FOMafU6LqhxVPiKtDlh5q4OrbBFjPweBOaFgG/AS/Lgt7Tc9GSlxNFfl8X4mlFP9bATYxt7gzgSZ02zIu/4Cx+uXq/z2lVUbQo17hGS3jOf+cwWVtmiWcAPZOgUXlhA4rAqYx+JK/NtYLJfxW5BZZmyDVaVz6aocbGT1HzZUi+9pDmCcIy/uaIteat5rCsQCXOaMXQ8dPDFnhRipRSuhsZfrYwRHGhBaXQ21aRCThQIydxrtcaILxd/On3pmDZLNKGKYKURIW7ZFuu3fOXpDonEvUpw8p7fPPHjDMOoDHvaRCmAexVQeJenmq9NyJeWHCeXX0uzGiILfZRFyP8OhTmb4J4DB+XswFTm65TRukg8ykLHVOuOgTppLQLZcrkOQ3jqskI+XPLjTAi/wvQ8nAYMHfexrIC5R/AqFjWy+O3DJP5F6egll50K9Bmy/hPt+V154Z7TeVkDV9HepSfueU8eCQWM8saPE3UONbl/0S426dQbndZFJf9HAFniKRi8jMp8EfAW4L3eKLSo4S5TCklbXOI02ql8hvq8LKPwoh4d9BJ/TVuDoShcly89H3Q1uurTRO568DVru0T5t0ztmHbiw3PilRf5SL2mnLj3/jx9tRyfuTDY/QrudPCO/IzqJW7ujRiRPJDFfDOjplvDL4J0a5gqn6vCLsHQcR89k5CEJer9iCnvYMQkt8pw9TOCSl10Nl0lEYTcD8h/5aemowLrNxVMIRxb9i48BYmj55W7bcWuILPfwYYq21412pGQEp5NMKI0XhuB8IMHqHwuQ/zHb+6krFOUSqtGCnFXdnhTjuFxU5JnYT014hp/j9SDp/rWkJzotL+DItBxpAxrWfq4rhGhkYdvWDoW7sxIlTtx1nr2u8oEt9zSFSXm62Or9hjE3UeHRyQe8VF6/K1TnxXhM+mE503j6TB0HKIm1CdaGUkhrkItyGWZMH9cJMAK1fXlwifdRXHZYZcLWkL5ApAwlR8gnITHHFYvYVThvgZz3NgkKkXA6ztum6CnKJq80wAqr8vKrQe/6dHqEfSelimFjKh8gg5Rrj2Pm1DSN7URL8WNzypPIL81z0He5397NO54xzvuPeIRj2i3JlMU4c8zdUOeHMO2CcmOSaO8HA+v8UJ649xGhcJ3NswtkvmEzdenekqZ4Zn/Pu2A+6J3gff4X8TLumA69WMlzQk2WDu3rPehD32orUPPQ7tpLuDpx3/8x9vzggsumOah/DRr52Z5nTX6NFdMs6LPvek0N7DpvO86r+0jtwpgyeznf/7np3lIttCCa+ln7uEv++9YEuZ//s//Od3pTne6zOXTvNa48v88xJ/mXrJZtqXr+YEPfKBZfefKa+vFN7rRjaa5ohvsZ5h7o+nss85u1nvxIHHBLBjNEp098Xk3V0r7jSof61DiqaSc8SeuuRFOc083veY1rznGwr9JOsLJ8zwXnx7x8Efs78kP3f/+95+e/vSnt9WS7C0ICTv3tq0crThYPeFP+iPeVxE+5lFgOxvhDEfyVOPiJxTePVFfJ6H6W71adVKfc4883eQmN5nOOeecJps1LWVLVu2NmDuatr8A5qlKKwfpzh1LO68gjllJTP/5P//n6Y//+I+HZYXUG/ef/umfbvsu+jJK+ve+972nZz7zme135X1u5A1kQBk99KEPvezNp0ncf//3f9/qQluU3vve975pHsU12T4o4WBt0Kb5es9cSG1uRzvPmWnwu37diHXdVs+5Evfj0BMhV43XuEcQp6F6iIaWLo0P/tcjiD+9THo4v/und7Qpo5S7F3wRyA5HPYreQ2+SXgBJa4TTRXjTw5lny5N8y1fyuAmEyfcz5Fv+Ufb1pxzj19OqiXLvy2HdMunLFolT3OlVK5L+uujD94gfX+EyOnjAAx7QZIAhmw0I4QufygTsDvW1MTc+uY6N7FR5rmlHvmqPzd1RfRS5zaglZeDqt/C3DHg22hVOfbnvwdkMX0t3fscUE+/H+YmCoeNS3PzmN98XIPN5c37uCsJTQSOMW0biVguRpdgyTIw0q2DeiBRiJQVr+GqZkb8qxEnPHnz3JPiOo5uOVH72oqdyElcqqBK3EU43MaTJH0EKkvdNoA7Ul/ynLHqlkHp1Lbl6T8OuDXxTivy487HyXvNz0DytQh+v/MkrResCW52F71iwU7Bl1XxGBt2xYDWJP7KlTdiWTu4qkoYG68tTtfxC4qRw1smvOHMvBSVmZUO4pOU3I7fLi/uwG2DouBC0uac5UhpIzt8D5jRElllUlYawKsCyoFuOEmYZZNLIgsCmImh2F4EYlVS/RiQMNvhxEYbCYdEWNkIYwUcqQwXVBtFTVQQVp5OSfi7oUObKaR2h6pEGr7emYFFVCuL0lFbOnhyPMsB7GpZRplWj8J08VITPE4Uap7xHIYzeA5mdpxpNUZBZS6bZVxK5SXnowRk07V944AMf2Aya7Fi1fuSXgtBoxaV9oCj5dZCDZtpY2pY00smywTGoHkf5DR0XIgk5qJINGTSXwo22UhC0WCrfkCvhNFzTj75BL4MpiyOofqcCFcDNbnazlvlf+ZVfaZXhVqaeFF5t+H5zi3ueiyh+e5xOkr68WEnRu0XgDiIEwkQx3PWud23xV6WgTg1ZWfClu6ys1qHUAfRX5/ld83KQ/BwEkVvp2c+RfFc/4ZMf7y2dnnvuuc2gyQCtLijVyFRkxKoUeTciMoWgKDL1C7QFDXnd/FIKyjFLonhjEDdixlst0wNi6LgQtXBoxJAC4q4wNVTDdCf9kFuO8k6PZBnP/2ng4vLOMyORgBtt6Noyty+b2ykMFZDCTwWE+v9RdevDHEQpBD2N/JxIEIZKRmzKKeW3KWpY9eGbl5RD3hl55YOr4eF4KOHrBbvLUHk9XiyKt7rXd5E/Mt+Hyfu0B2Vnr4qVKhuv5M/8XsdJvjJSlX//UyKUiZWP29/+9m3XYy/7Sddvz6SVkYJpsOkDt9/4jd9oe1B6/g4CplA/NqK5AJrlfe6pp7mHbv//zu/8TjuZh37v935vevSjHz3NmnE677zz2krEPK9vp/acoPut3/qt9qw0Z6Jh1prTPK9rtw+9+c1vbmFYWOf5WlvVuNrVrtZuTppHHO151atetf3m35MF1sEc/7Mui3Oui32Ltf/xjuZCbu/87/eIhFtG4qy0yv/xEn5j9cezPN7tbnebXvayl30GL+uQ+ISr8TpIdfWrX73V6Qtf+MJ2ItDKkbwpP/7Wzad4hZGGU6zqaJ4GTnNDaGcJvFtGwp8oqmnVeHse+jRTPiNe1EHkaUTk1cqH1SyrFlY/nHP55//8n7f4UmfzqLqVh1WxP/mTP2k3NjnUZuXjkksu2ecBr86yfP3Xf31bsZsVT4vX+RArg7OSafGFRjyvogMpBYxRBBrrhRdeON3xjndsvykJwjIPldrR2XnuNM2jhBbmkY98ZHMnZN/6rd/ali8VBFJg97rXvdqyoqWiZF5c/CmgV7ziFdMb3/jGVmjzSKEtH6Uya8ZTyATXe/A+cSZelIL2f8L1VOMeUXgIrfJ/vKTR4jf5Qn7Lrzro+VlF4kg5pMwo43l43OoiB834Aenzt24+02iEUZfhPbSK3xNZnjWtGm/PQ955epfy6Xmp/4/8JF5u3kfuEEWr86MkLLn7bckcaVvkex45tENtlLNToy95yUtaWTpJq5N917veNX3DN3xD6wQtIVs+/Xf/7t+1OEI9z+sQrjcPNROGNeo73/nO0/Oe97zmRlPZv0AQHvOYx7Re23ov4fJ88Ytf3NzOP//8/UJScE636fW9s5acdWQakJblXitOutaSHUm1Xk+bvuUtb2nr3AozldBXEhJP3OrvbSLC4zTlPJ9sjRSpD1QFbx2qZaXe5jlyWw+3tq8Oa7kT1ijyTUi84r/rXe46PeQHH9JGjuLFq7SX0Ymsn5qXGm91R3nn6d0iWfI/ZZcyl09+9exGVkZGntqE3x/84AfbOyMC4JZRhrjmqUDbJ2MkIa7XvfZ100XvvKjt4xCPkQF+yLwO2J4KykRn8DVf8zXtqL22VanneV0S6sCYBWX/PAFjlI+gzo15/z0rK2IDYJ1loOQ+F97+HGkZLPNY7rEC4eANo2YOyMwCum8PMGebpxp7z3/+89vyDiPWXLj73+uTXo13LtyWPv7z5Fb9HAaEP7/NOf22LwMl78dDMfwhuzalJy079fJlZG7Kry/DdVDD+O6DpWjpjXifG9dlvw4vVb57+06IrIf6PAnPTVthgCTTDswxpo/kL2Xvt7rnRxki+4EYRr0jG7bfJw4Hw6wCJp4NMXRcG5hirZZR0Ci5y4DMWPdF3jE+csP4Jg1QXGkQcWOYyeYjy5SMYQq8ryhLkq44s+TDyGkVwwpIn34VXu/8X91OB8JHLS+GQGW5qGFtSuJCThoq3yxr2TDmnfSS9okoD9b3vo6kEz62jSgAnZM8JV+1XuRrHhW0zw9YJbMnRJuI8gXlyphe3eq7yH1+u4NTGjZVafyRk/jxpOAdzks8G2LouBFkSC+NCFHcI0yUAfre7/3e9n8YXwcKwSWmClzjdpjHwRSjAAopcRkRWE+2w+tnfuZn2h0EWaXoyUiDZdhmJnsa3KRsGTX8HkbIp3sqWZwJ2ihfByFxzVORJpARPuVgXwJyzkN5x73ydBCIw05WDWkblUH4XkSW4q0OOClLAfg2qXpTtvKuHi0fzkP91lHNU+q2/0OZjJRCkLqZp9JtVY9ScBw7o4GEFb/2Ik6jvYTfEEPHtZFGachOUEeXjdJYMqFwuOn1834dGMamImqFOKVGGRmp4CNDKVCILuFwks4OSgeJXARi6JVpR+2xxJXhnMM+tomqvBPREI4HESS/LTsp4/REeR4P6b2iEKSl5/HbNfgoZfRDP/RDn8HbJkg+PAm2rdrbSClzMuSjuzq8TAEs3/ZD9sg6Jes0rTAhsiwe9NjHPvaYcIG6Sf07kOWkZyXHyC3V26NgU6Dpu3htijIi7uNbBwc2NIZmhpsxw9KLAyKWGyt5Z3nLOysRM8OXvVmPZiGabne727UPcvg9ormxTHOlNF76+IWJW97nUAvjTKy/uabN++SJtZz13eoHo2aWieYpSTNoVpIOzJXY4mD8mRtX+y2u4yVGJMu4lb9F5bGKGk+f2msW7ft8130uc/004X8W1OlWt7pVW+7ilzFzFu7pYQ97WPtYTdI/nnxZUpsbVCvzUTwHzdsiCr94r6SeUA621bL1Lqs6jH2u7bP69eo/efX0p2/402luePvxImHyu6eHPOQh7fBUT+HJUuI8cv2MfCc+fuYpXVuWly6eGOhdU6jO/PZkvCSbDkVZpj4oSfW4MGdkvxcYgR8ab9MRAui1GBpn4TxmlFDJdlHpL+IhvaDNJebOtpkyyvCfdIxwHCqxPdWGoNz406dJs8+Koh2iYkQ1CrEbbZQ/aXpKxzsjmbitC/5dmd73MMdLbD/hpyJ5sFkMGSmkN0MXXHDBfjkfpD5rWrkaL/k5EflaRvIijWXpGInpZcmU+yLIit2LsbUAg6mRpNEx+4C8kDGjrJrXClukk3ZFRh45rl7LB1LGkeEaZ+SXu9/8QPxXvxti6Lg2ekaTmYBbZXZTCGcbqNUFhdgTt1yp1qcd5B2lkK3Z4mOE1KjjR3opXL81RvMyB15ynVoue6nCjMzvDOXcU+BcBoNm7n4Uf600/yd/qyCcnW9I4xyVwabk5Cre8NGjVwp1uKzBaFhsELW8Kr+rIP6EpZTcSCSNvjxPJIkb/1W5ITLgfoznPe95bQhuO77pZlasAuXiaeWMcY+dJcQe5d2ichDWOx1N8liR8pV2/FfUeHQ84spv5eiZ394p0/xO2ANg6Hhg1AwFGDwok8KzRei1R0RIbRmNoI3STlx+W8ZRGQREhRAG72phgrA1XOKyrZRBk53DPJBAmccRFPHVntUBLg2QQDA6mVfqZaRT418GRj7x4flE0Etf+tI211xUXr1SiOCml/VELiep5VJ5XoXkH3LiNg3mRFPidC5mnv41Gwr7iA+wGAHgZVTvaWx+xy2ndVMW6txSYvx79hDWu3nq18L0SHmy4cT/CH28I6zrbw0MHQ+MPjM9RmGWQUWpNBp6RApVhevV+R+lCXmnUaiMGOwYbpJO/C1DjRMiUITDkNJedsfFLRul4itJlxJj9Dz//PP3971XoRKvOE1x6rmDg1KEj6FLL6jhS6PmKwgfDkGF/4ooCKAQKZjUUR/XunCtHUoD8ZQWirLwzP/x1/tBnpSx0WNWqkwL8TmaLo34qeAnivJhD3tYiz8jhRxIWhZX3PGziKwUuKMh8YxQ4zoFGDoeGH1meozCrAMbpCIYPRESvXca9jIYiqtYjdPT1efiFxb6dFehxl3dxeWYLIuxpVifHbO6cckllzR+5SXCDEYwriSzSuJz9JRMPqibRnAQSpkZJuMnI6LKa8UqpRDCE7h7sE6TalzrAk+mZqGklTTqSCn5yWhMh0A2fvEXf7FN80z3qtU9dRPlnf+DysciUArKRQciXXWI1GfiHIUD79ka2KFq+VWyj8GSOP89fz36+E8Sho4HxigjFaMwy0BgPDWYEaVhOZ3G3yjNCnsYhMlRYJW1zEC0ColX5RM8wjNqdPFnKqTnyg5NS3PpeWrjHw2p/V4kWMuIveP617/+Ph89bxVRCqYPSa+iUvjVoLOU2ce3CuGHDUaPGZJWFEBI4zHSowCMAEw9+nX6AC+pj5rn1ENQw4xQ/dlTgKfUlynUqjjIhZEgRdKXX4jCTtklvUXo4z9JGDoeGKOMVIzCrIKCtdFjRBGcBz3oQfsCsAw2jaCEY3i0H0E63vdprwMVisf8Fo//g7xfFL/NX67UsuPS6ojpR99DVoWxCdlMk63lfcMZYROl4H/lCIbHrjg7SBmmJzbXR1ZabCwzUmLhd5Sbld/UJ2XbxyE89OXsd9D/H7dV4E/npANBMbiue1EQY+QiEs9LXvKSlgb+K28jjOI/CRg6HhooCI2KoW5EEVY7yPiPUCyCxhdSuehOd7rTftia9umCc/EoiqBvjKtIIxWGcTa72iJwfVo94s925JRtxYjirsfTKwp/0LK0E1V8uWIvPWiQegzqu5MFCoFSSkeiXvzODcyrYGOTPCV8KOX2pCc9qZXXMlvPqcTyI2qHgObCarCJaC7Ey1z/f5rLtD2/vHzXbxnZ+GHzkQ+uik94H/icK2ThxpNTQbPgtafvJ7qDAi9zM2zPdfJVycYkp/Hcs2DD1dyw2maXk5G/bP6ZpzttQ5i7NNSFsk2eNiGbfObRW7v92J0LiUcZbFoOJ4JmJdk2Azm5KH35dLP33MDX+qq3ME7+eqqXnuQvsp2yPAzUtMNhBQ2q99IDmWePiAZ2GzNNy/9cAQshTvsJEI0/V0azovfpnkroiTxNYwz3UQxpm5LRjymRb2um7MSd5yrwJxwDqbLp0VPcPFOeVorUV9/Lrws3GyNLiDEaJq5RfZ5MKAtPezNQ7AlGReSt99+DHxvdUEZ+oZSdW8vkD05FntbA0PHQIIWkcuwHWEQakSPbq5QCMDaiGLYcMMnSWp/+qQCePBcZUzchU4Z8bFcDT9ywTiPdVCmE8i7KzPzbitAojWUIj/miEtsCftIAaz3WvJ0sJA0GTnlLw86VgqtgyTLL6aPpQ+Q2/k9FntbA0PHQQCFFUFREFVCIXQA5oclvet4RCJi9AbWCxMOw5v2prpSk59DYQUYHeJcXwmqEYIOUPAbir+jT73FQpRDCS/zZLhyBX3ekEhg1OaQmPluN1WuU3Cb5ORGwYmS1CmW0aju8chr5r2DkVR6po0rcM+I4VXlZB4fepjCX3f5c2IGUnuYCbfYB5MagufD3byMa0VwR7XCTm2/8No+bK6SFnQXvMl+njuTNHNwtRwdJX/hZOKdPXPqJ6Tu/8zunuUdrh3jkSf5ONeEFSdt9mw6yuXpMOc+Nur1bRviGeRo1PfzhD2+/f+7nfq7dStTPuSMXJ5tu+fW3bHdLypP8SZetZp303SDGn3yc3X2JC7FLkNfU42GgQ68UKvk814gYftAtbnGLJniphBF5z9DotFutBJeVni5ytZqTpAchxivGL0bF3//9329GuXnEsbQMTiZR0NJN2nOPP73oRS9qRsh1DGlpdOgZz3jG9PznP78plZ/92Z9tbpVOVf6+5Xaflg1lTX5cg+a+0PC5jOaR22W/xuS+xSiE06HEF5GcHWrMld+ejFdzwR0DZGiGzKft2st0Y4S8e+QjH9mGcxmyu5/fwaukdapg2oCSh03JlMHGrcp3fsur3xXxswiG6LOALpw+wDokPxkyC+NymNh8RulW4DNTQFu9GV/Vkwt0aj7Wyc/xwt4Id3bIAx7kx+5UaS+TsyDXsad+a/n5bSorLlOIdcrmFGHoeGiRT2ahCFyFjS78xTDVIwVv/T72iAhwPoKSxlTDnShodJ7it2fCvBltak+Qd5Zw5y0qr35vgpQHvuTb/NmWWzcGobriE8HehGoYNoYYH5N++O6BL/x4WudHvsyUi3q4Lwt/vEiDz2UziHwhB6Okn7LrEXdH6iOXyiG/Q85o5IDcyc7Phhg6Hlo45ILSiFLQAWv1ssJNZasEB5NQlEM+WpOGu6jSjxfhwZl9hO8IzSqKHyObbO0WX/LsuQmEST59c9NKjJ2VRk0UDzqIMggJq3zF5TfFkB2kywzCUBtKLqutpzPz7kQidZOnb0WidECUeA7fLZKPdEiuRROmopI7O6RT83lIMHQ8tHBkGUVQ+0J/3etetz8UW1RpqQD34gkT4be3nnb3LkJxohGefEULaTBRCOs0PrxSCA5NiasqMEhj2QTOLbgHIgd9HCwSl9Uc5ybwdlBK2Jo/e0pY5VMWyxA/DojlG462qvf+TiRS95RWvqCeTsgRaO9S1jUcqA/hvLMzVb4rUOTNFu5F8ZxmDB0PLeyvN48O9YUOvjHJ72gKUStAz5jKzmjBxpmR3xMJx2QpoFDlfRWZMpiHEqY0mPBJmP3eBGwHjlRLO/s2HDZK/MrbWQy0jtJaRAmbHtfavXKo5bII6U1dXoMoB7aGkd8TAeUiPXcu4LVO7fT+3kcZL4J7KHPJbg/xKY9+6neIMHQ81HBxCYqAVaC6bz7CPwI//Tl3hqGaVvwdFLXhpgeyMadvYOF9RGmsenJXr4sjQlnzkt8V3JNuwqQ3y0ipL7+qFMK/xuDWKWWenu6glPB64SiGpLMKjHz4dB9F3JK/EwXlo+ykgWJXcVArUwcY8RxenKdZRPgXlxOeqaNDhqHjoYaVA6RhVYEG5Pp2/mrjWISHPvShLZy4CKsRg7sEVLj3fdrHA3G6hAWt27DSS1EMsSHUuXifnx69P78ZEV0Cg0blV5UC/3nqnXN8OH43pT6c6UmmbKt6X2CY0wMj0xxuaYgnQjngQTyUVYzAqatcyBPU8g0yOnXb1qiMomDczN2HPUQYOh5aqAhn71UURJiDuH3VV33VfkNYBvc29pVvLiitCCl/lYdNkUblTgP2AOn0I4VFxF81KtaGQ3j7/PSIX2A7MDrIVAn15Yd6pSCe/Aa7+Sz/prw2oaSBEt6SX3Y+9jxX5J2PACkXI5dMI06EQoCkYb6Pwq/0sut1FWxtZlAdUcr5vPPOW5rX04yh46GHCz9rIQchN/Gu22jcl6/S01AN093fpyHEz/FCPM7Nb9qQjBBiQ6g2EnkLf8uQW4gJtANGKSd81HILUFUK4vBMo/Pbk4LLNG5TSjooPWe2REsveezhnVESHn71V3+15cF5kfA5CnMQ2JuQ0UhkwtmHlMUqHm3LRglbiUJ2xV7udjykGDoeeuQblb1QpyJymWttPAnrd+B/DSaNNcN11njvMr9MuMSxLtKQc/JvFckDwQEKIasM4qh8L0LSTBhPF9SIN/EvA+qVwjK4tzCGs4TfhIRJmRsxWAqVbp0iBdKLuyv5c+mJlRxuUVzHA3H4ahi+1EHkQs8+8j+CqQGqezwquV4/5TsKfwgwdDy0yPDZkhaKMFcglWnIzf9oGlAF2/85Tp2hNW1eb2SqYTeFT9wtEpCeotSsMlAIwlfFtg6SLtuB5T9pp+GNyqsCbaIUpMOwK37pjHrHVZRRC9JDu2ZdnutUCZJe4Hp+ZCqz7nVzqyDPb3zjGxs/KTMrJU7RrhO31RorS8lPT+K0D4TfnVI4QagVk5uZKwhYhNOasoJPDxIhr3GlwRnyCaPSIgxGI9Vfwm2KeinpKsJDFII0k26UG16WgX/DXyMdZDUlKyzi7surB9pEKfBjCK/huJ4sSjVluIqkiS/1ll5ZXKNj19LKb2Uhr9nMduGFFzZ3PMXPQeDuTIQXefDMJ/N6JTWCTw6G5KsnF80ylqb8RnEcAgwdtwLuZewFGkW49PYZjqZCF1UGt9gp0qsnvPfrCMQIm642mDJk2TEwHYhyCO/JRw+jA8dxpWc3ni3L2fSjwdbyGgFtohSArUJ6eklG4KxsREEsoj7d+tsIp1cM4cfvlIce3D6L2njj5yDwrdHKBwWlEY/8joCXZeSyXvnAv+cojkOAoeNWICsHqcAR5XLNVEQEOXFwi4DFQKSHINAEzafuvatGvmWocWeKs4ykAfJAGeVw0yIl1AtS/hfm8Y9/fOudDMHt2edm1JBdidJZh6pSqGklnQoH0KyO1G9vWOVQbhkt4CnoaVR34TMbnKSTOqr5Bb8ZYlN++Ywbf3m/CvHnOxzhB6/40PN7l/R7ZMQiPTcoLaLkif2K30XxHRIMHbcG1o5HghVivKrfAazC1IO7bwigCLSem03Au3UqsjYk35RYReHdlCGfsKv89oiywEt48rXjGN1+6Zd+qSkCfhJPbjFaVk6VNlEKbioW72te85rGS8CvEU/4Wjdt/qpfo56sBI3SD585o+Dqs01GdeGVQjOiUu/S1ykYrTBoep/0atjePWdZKiU/lIwy4g+/i+I7JBg6bg0MlxV4GvGIWJMJit6+r4wIRaza5vKhCKc7HEcNZITEwyq/LuX4s7CbCLSttLEdGA3Yllvfhxd+Ipjr0CZKIZZ6yrm6S9vT9CUbeaSfMl1E9X16VzsfTSXCT541Pdfk5/P29VOA8ee5CGQgtomUkbR9xCfvPUfxhBfbxRdR4nRMnt91R52nEUPHrYFG9LKXvWyhwHG3PJmKqBXbV7LKh+c+97ktHEUTZWPDzCrhCpy9MMKIMCwjCqFvzOvAB2VyytPWX9+45F4bcvhl7Uar5vihTZSCD7NoQA9+8IPb+4RJQ0q52/brBOY6VOsxZWjEZ8TQ81DTci29+nJ1mmkE9+pvBO/UV0YISdsR/V5mRuXBj3Sc3hxR5JLSzrHvZfwcEgwdtwYK2Bqygl8m9PnU96jR9GAsy4nBCKVhcIaS4uh79LgREqsioQhagAighmQOHKNiFeAe3kdApeFmYXHZ0efbA9LmL356yM8mtEwppAGGL1vKUQ739IhfcRmi5wvayjUjgVo2qP5G8WcqkWXiWv41vVzK+wd/8Adt+sRf+OjLJ3mxqQw/6QSkl2861LhHkC93cwhP/pKXCpR9L1uCoePWQKWwQOem5zTiUCpl9N2/+juIsOXzcpBe33zduzQW4eM/Q9VHPOIRLb1QLyBZ2fDMR2gSNnFWRHClmdGBeGyQiVW8z1cP/nx2f11aphQqfEPSrUgUaL+no0feeVLi9ZToMpLXSlYHsqKUfFcwcloNQc7I1HQ9k6fUW75KJZ3IjoNQyn0Ufw9xuOshyiT1HHA3GmSX4ndLMHTcGqTR2NWmUkZKIRo8c0SVuUzgvSfwNrGEVK643ezkfXqdGlemDdIKLxGOAGUfgrC1510khHo8n5NDbusxlREm/vPbcwR+sjlrHVqlFMKz/CKNMHyE52UQr+VLl9ooE+Wkjvq6QxkloPxmY7AlOqOACjyw8ItPnbE5JR95H+CfcpJu0raKUpeh+/h7MLRKB/V1Dcjn7+O/pn+IMXTcKqh0FnfWYhVRhcvvVI4lLvM6/iPYI3inAg0hQxFIadS5YXocSsJGoUqEpQoIWL5zDXvSiqBUwa1gwNII5MO9Bhkd5L3fi6YNwI+4s1y5Dq2yKcizMsrNQjnxl3JbhMRR43UFXnYAjvjjruw9K6lLNoY+jcRtKRqpE3xxz9N7efAuyjtp5Or25LGPv4dToyi8i6NCB+BwnrgiK1uAoePWQAWmUfzAD/zAfsWkEausWkmLvlG4CK53E0eG/cjSk3QjYPDoRz/6srfHUu1F/L7zne/c0saz8ARL+AhsBMfvfFRXo8mpuk0hHXHme4br0KqRQuLOyseP/diPHVjgpeHodOb1yDO/Q3iPW8qUYhAWL6OVBo1eGIfj8i6w2iBOcpL4LN0mbFDDQHVXl4soeagnbmv4Q46h49agFrReVK+aoSNS8RX2yfeCtAzsFZmjquRMRbKphVAzNFWlUSnKyXv7EDT+mm5VAnGz7yArC3qiHA/WwPG9CaL82CPwvQ6tMjTG3cdgkU07eVf9roOEEaf5fQy8eFXey3j23u7J2DNAnlO+btZS7urAykTemwIicQd2r45uc+I/z/pbXbj6ryc8ZdRhKsnIK8w6snaIMHTcGqSiIqjWzZGKSeVUoHzya53ejdASrmorQP7PUd9MG/KuJ0PINJyMagDPVdjYMawsUDyW1eTFO/7wkQaZMOsgaVmydNvPOrRMKaTHs0eCkVGe61Jh738VohTydLDJygHSwKIYUnch/6sDZFVCOPyGv9RtDL/sQ6aY+K53HaTO3EcZniqSJ8/E62lkiLee8BV3hulaX33chxhDx61BCjtCrNIcAFLZEIEK4uYbAmlofZwV8WMdXjgNFuklpecyjureE4WQfQh6C2H89hRv+NaT5fsCjIL1KvP49X8EbF0kD+Kwn2MdWmVT8Mzn0DTI8HaiIF2jBr28EZ86i3JII+7pne985/5JyYyo/PakZIQ3FeSWj8VGqbC3SDOKpKLGk986g3QSI8I3gyVjKv8pxxrHIcfQcWuh0M31CEEEqSJCpQHqmRNm1AACQgYu9kA5Vm2XXY0b1XT6jUnSSAMigH5bQovtwNCZXSTC431+B4lrXYgjvZuNRnhbpMBCq0YKnr59IC4rCOJOGr3/TVHLyNDbNCp1malbKPnIVNGydFYOxJMyM72jnIW1n8L7TAmdYKWs4zd8BFVRpDzscE3n0lNkju3qRNTfacLQcWsRgbIrEamgCpUWxaCR8DsS/qBWJPsCm0XsCfay9/EjT72F6+j5w1MVkKQX2wH/TmhmOhJBjP8K7psiUxZLsiiCu4hW2RQ8H/WoR7U4XO+Gr+Sv939QJB1K07kGaY14jsIIUQzpofGjLOVDI0VsENyNzCzvUu7S4mfEf8ogdeJeSBRFNCIdjmkK/+KsSLyHHEPHrUWE00Udet4IUxWqPAlTdgTWHqGiFwrXaHGzuYlg9PGLUw/mLAN/EW7h89s+/YwOKA+Xx2q4/PSCUwWqf7cOajjLm1EItSH1tI5ScH8BMiqr+TwRqHGFB404xle9Pv6rMbn+T3HnMtgoRHHGMPrEJz6xjQ4yRYNlZRsejAxznyeS7oiyJd7+kpT/svgPIYaOW41UIiNTGmsQynzSvgPHf/s4glSmp3g1XAKK0sAq7By0oaWGJZjhycYaQoucva8HfaBvXBGooL5bB+JL/PJprlv5HtEqpYAPy4GI8l3k96AQv/hSFlGowB6Af6BQQxn95WnEkPMgOS3qGLbVJ1RHcUnTs0d9b6qhzJIG6suQETv8J1xQ4z3kGDoeGRji114kFMGCrEaoyFp5qdzag5tCZNpQhQMZNjJ2JRyBohAyCohAC/vYxz52P81gJDjcKvr3m8I0JfleRFUpjNLXC8sDKz67zCLeTwRG6bPT5Eh2VQwoozdPBlvlnrjUR+7KVFfOYnADeYi/itR9NkOl/kJ+pywp3IxQhFsU5xZg6Hhk4MDRiGplogc84AGt8mtF+h2kx7DdmDLoG5VTdf06t3CEwx6B3Ptn774lTmlFcCLsI3hXMfKzCWymwXvPf6VVSsEWbXnR6Fbxf7zo0890wOE0yjwUpS9fabTcnv70p39GnLnnItuPU7cjeG/aFeWTuEP5X7on4uanQ4Kh45ECQ5WG3FdobRimEyqfgEQAU7npSSIc6Y0S57Of/ew2guA3jcScVS96wQUX7Pu3AzDzTP4qj4tQeYGRn03gjEh4X0SrlIK7IoRf9THfE4Gads+T96YBjmSnbvNEfit79pvE5elr36Z53tvIJM4omx5sSG6yEs8yRepyF/7ryGSLMXQ8UtAQrdFXgamkoTMOunnHpSBV8PwWh0ZuB5s4qoKJ0Sr+0+u4Ds0aPjK/9dUp76J01hWexBuM/GwCS3LJwyJaphQgV5g7+zBK40SiT7u6K0NPthKX9CJ5Aw245pEi49dqhvAuPOFHg895mFGdxI6wbF+CI+yZNkRethxDxyODCNPNb37ztktwFfnAiR5emDpqyHVfFEiEzrJc0olfCsL9hIg/SiOKwo46fhJmHST9YORnE1iui7FN7zeiZUqBW9b4rf+P0jgVSFno4aNsXSZTTz0qf4qBwvd0fqQ2frdQo3yXMvWUvOY2pkUUOYhyTPgjgKHjkUIqS++QylxE3j31qU9tQqGBC6fXDxEuyHcMCWWEiD+jAu8ZspyGJISWJ2PtDrjX/xchcQcjP5tAHGnUi2iZUnBZrqVea/yZMp1q1MbrycbhtCV+Kb0sl0YpIE/KIXdYgD0KNqJRjg6MURapTyOLRXJS3V01hx/h1q3TLcDQ8cggghNBcvNPFZSe4pZboC1ruaAlAqaXjWAlTo3D6CDLnO4rtHnFe/PZ2BRsieYfFs1he6QxBiM/m4DgZvi/iJYpBdMPZCv5KP5TAXzgTflS9DlE5Wi56R8/bCeOqSPlH5uAoX698ERe1Y3r0nKGw4iD35F8oIywyEU2KR0xDB2PDDLvTCM0/6ynHnuKW+4IsC8+PQODlmlIlIF4GR9z1z+bRBSG3YpZy49SIGT24WcrrvCey8BPxcjPpnCxafI0omVKwRkQlMM+o/hPJrLngCKm4OXDCMATLAvmKjV7KOr3LjONMIqrG5fyyfksTfe3Z1USBzIVdf5jVEaJd4sxdDwy6CtMJdpTT3jQqDdwuEbYTBsIm91017nOdZq7OAinUUAE0sWdV77ylZvCoIgIZI7WRpBC5r0OZImL/2WC1PM/8rMpcmP1op6wKoXMv/32tIxHcTqj4f8TxdMiRJlLP9M507JsAFO2+MmSob0TOSYd2JuQUVzqwhJyenlGQgpdPTqZqk7sfvR/4g1llODsh7Ano34OAYaORwZ9pRFylX6Pe9yjVTrSONK4Cdgd7nCHJoT2FvifBbpe2mrHYkYbjg+zF4gziD+GxTSikLQyctDTZdddwuR30PPfvz8INIIMp0dUlQL/yRPkmLjVFO9PFE/LkDSMDpy1COE/is1vl9+opygy4SgVTyO88J6GXi/LYZNAphdGk0YSuddS3BB5yaUtSaMi7luOoeORQV9pkGWpfPcvS5LIISlCEuGz+YV/DcNIgO0gvZNGncM3I0RJmKPaM18bYp4Mdj5/VwW5xtHzXt8dBOLQUNLTIsIeoF4peApnvm6eDvka1IngaR3YT2A6hsf01iGKwSWtKSP5q4osPBppsOtEKcOTnvSk/fypa5TvUtrQFkp9UfL8J42kGSTNLcfQ8chgVGl5qty6l15D0Thto0UUQPxysxsRGf6zVhMMcQA/EcT8L2zc7Lt35RhK75Yn4dSLGfYmvcD/FfXdQSAO/Dn+G0oDAbRopGB0wE++BpX4EvfJgG3jPt0u3apQU3ZOPbqcNflKuBFf6pa7HaZGeslvjMpGB5lGMFSKz2gi6bIHZQqT9DwranpbjKHjGQUGJoJgWqChmxJkDwLbgfXqjCTMNdNLRij8XlcoGLFqT0e4EzcejD5yWUiEfNM0loFQi0NDIOzSrEBVKdQ8Zoidewfru+NBRkmQOE0DKGyjOGUUoPDN2ClsRY0XxFWR3l09MyKHKAH+7WUQv5OYplmmd1acdAimFYnnROX9kGLoeMZA5drKaojvf9OHGNEsv2VXovVsw0nuhIOyiBBGUNYVErf7+mZleiBKIkLPzfCcwI92yR2vICYudhC0SiloRKZPfhs58eNL2tw1rD7+gyB5Up6UgWPpOaLcK1DEEOx6OzyETxjVQdwqKMbYiJxatRqBcmWe7zioBxe58u94eDZq+X9RWkcIQ8czCirZ07DSEqPfdjBGIA0bcxkHxWA5ysGoKhzrCkjS4t+lJ2wKGhohjK0ipJc0h8VXwm+S1jJQOLmNSJoBGtkUgMGVn3zRWnn08R4UVmuUeVaFQrU8KEs2AQbcddNOeQXCGQ3Y25CvNtnB+rSnPa2lYSrCdmT7M6IAE47SUg41vj69I4Kh4xkDlQ0qW6Xrxe1K1FgITvbMGx24egwRVO/tZTiIcGSEIU3DU1uhKQRxppHWoTKimOoyWI1vE0jTUy9P8FcphfjHp30aFFWMq8nH8cApVvsEMk3IVCqjppCbtHJrc+VrFVI/gWkhinGZfSSbmYyejAxtYrICpVOgiNyItSi+uB8xDB2PFKoA9ZWaijUdMGzVSJDhfa7ntnxp+pCGQ2AjtK94xSuOuf6rptO75f+KuPtakdOW0hd3FESQUYShrt4Sb2kcsCyd6lZ/s48kTwHqpw/8Sw+ZW1cDa96D/2v8+V3B3ajAakHdRJZ85rencvBdTqO3Pq1F6NNNOPVrdSHpVGj8+cQcxWPJ0R4GKxP4cNQ68Ym/Iu5HDEPHI41aqYTGfDErCza5uM/PvNPoIF8T7uf9hCnEYp1pR4aYi3rRmnbSJ7R+e085MHzqyZKGtPs0/e/jrj7EYnrRz+/7NBK/tNK4DJ/FU4FGSsEVYwhviSvwv/wm7zU9EIcRmN2QpiDZlhxFl1476fufUs5VeaM4F4G//Jau/6382JatHKMIAvXJXfpO0hoVUCCUA7tDlm7PP//8FiceKpLWCOvwe0gxdDwySOOMcPeValgcY6K97BkdgMMuKIrAszbMSt6z6Eco11UKMPLjU+rsCTnZGYHWYFD48JS2pTlnLjRePXEaRI2XG75SFne5y11a2AoUpcAf4CeWelukxZFVjBq/MEnThTMatTsXXvva1y5UbCG/2Tgcgc7IIGWYdDz7NEfAW8KyH+TuBORZEVK3yNJwRkLC55IenQXFFh6W8VLLYUsxdDwysJONYSqV1FdqNqwYMhImftJwWN3r7T7LKD2dyzayr34kNH36vR9pA37xYLTyUz/1U8d8wIQwE2KCKs2+sVEctlhTKgyjLOy+npWGkrKwdz/hA+QEKL6iFPi3VwDlbEfiAoY5Zz00QKsmrnzTwBG+ErfflEN1R4yLVn1cfpI4QY+d3+Gjvh+hll2OPmfUlTLK7/yP8MK+4BRojU9c8sWvrdHL6g7IW/0aeP9+SzB0PNRQ4fX/vnLsI7DEaM6qcXCrFRT/97vf/Vpjsz8hPV8P/nKXQhp+hHkR6ZksYyW9AN+jNCpGYTwpKD0vJcW+UQU6I5jwVt/FncHM+Q1Ky5Kb5VZx56tRNU9VKSg3DS1Kif3EGRAKx84/h8FG91SID19QefKkGPCDF/Vk/t6Xwwh46d1qWeV/06kcUpNeRdxQFJQnu4Fbtmt8kGmZ6YSRJKOw/2vaKSerMrbGG3nmQt7eX34fcgwdDzXSwOsTLLOZ+xnG0+oEUsPnp+4rAIrDnXoRyFSY3xXxL17xrSICBgTPUd5cCS9tafTx90h6gbBxT3i9mYbLIp/1/NqoEQUG+KjvuCErKeLMV6PkLY3Ebs2k52kzlXD2B+CHBb/6R/6XltFLlGdPNgFRJI47UyzVDkIpJ6+bQLiUixGhpeLkEeGpB16jtDyf/OQnH1POFdzITurQyMsUM365+W1vi6v62adcumKjV/jyFB76+A8pho6HFhFUha1xmHsbdlo5MAR1ApDGt3xmWFq1PyHU43pam1ahfWWJtyJunj4Qq1ckWITJcxGlUdiHYPg5inuE8BH0yiTC6bcnm4ghPcE2MsregzSM8JEGEJsEw6r4YyvwrlcKSdtSKDKF4J4pVQyGSSNPlPiMTuwBUAbZESiOqhACeUs+N4FwdRv6IqVQSXnwR9mn0fb8VFQ/GVUmD7e//e3bFC/+wO/Il99bhqHjoYYK8VQpbAJOthGKVJLRAWKZ97+DPIaphnbm19wigDU+zxG8U8HAOs1whghWT2kMngQxjdDNx+lhlkFawcgd3xG0CF/84s8w13q7A13SrJea4klD8D/ejZY0VlQbTaYP4hN3PrNP8LlnB2AdKYjbtMnIg4LywVbr/7WcIQ1K3HGv7/3eBKYzPudX8wiVvKuQdzKTD/aQG3GFhx4pb35qg5cXv3VI9XJYxklnS4ysnJ1gdE0cW4Kh46FFhCEwErDrrN5/mB6TArBr0F59wpBPhh0PxG84aamScIkX9YK4iFjjY8xK75PnKL0eKYdF6P0rF8N/Kw2GuNLX05tzs6Z7V/OB6uqDOE2DKADKxkjL3gz2AEZFZW/Fw4hNXfTp9+j57THyH17ipkEa6VkJMXIbKeee1E+UtaVc0zpxp+wrD+vCtmi8mCrgwWY2S5/Ksion0zz+U55bgKHjoUUVGOCmYlh8CYoeSgX58pPr1RmdcjejkUMfflNIL0J0r3vda39TUwRuHWIHsAGp3v6zrmKI/1VYFTYrMlYO9JqV6j4FvagdnkjDT1xppEkr/iF+Rqg8jDDyLy1Qz5QSRZ9brdgw1lEKaahkQjwgfvz2PCxDRgd4cOrVb3Yp+ypCZMLowc5Iypixe9N0TjOGjocWI6FJJedDLahufKG9CQRDZB9+U0ivVrChYX8kehlFOJEj2Ibk9W6CVUi6m0C4lEX+r+/tGkT4wl+mD6DM5MvJ0YzGajx9XHFbhOp3hJF/dWt09sAHPrBtJkr55VlHOT3xQ2GzN+SINdQ63ATC2YSVumZc5E5ZGUnZ/UrRxr8lynwCP/nZAgwdDy1SqRXcVZbfhsYEJ+52CKIYyWq4g4CARqDqM9+tXEb1PaHK/xqcnoVyGKVZIb2Doob3G9+QT+zrdXulkM076RUr0ttWt4RbhOp3hN6/0R8bkUaNt5TbyJi4iORPPPKqp0++R+mvgumSaRiDdg5v4U98yoMf92LolFwMY6t0/+WwLcDQcWuhR7GPPRtIDBeRea//CRo/5sMq1Q62HJXO+4q4L0PmilZBLIWiKqTpVXrBzf95b1rBSJf7FCrW5WVTiNcyG8rKhdUH7qYOekLkboNR+B4pt0VIWfXQoDIl8WRApCjdspxy8uyRsqvEzQghR6zFKY2DKoKAwdVoNP+bmlpdQllhwjsDq44pt3atMmQeQgwdtxapAPNfc37zZXM8S3fxQ9iQCubf/NCFnYRG2Ioa9wjxE4ETnws7WOIzHIdQ/R0ixNUm4bee2XDZ/vsqzLXxxO14kRuV0pjYFBI/Iy1SPukJlyHl1mPkV76SN34oa3NwozrLnUYDGRGk8ac8A+Qd+B//wjjXkT0oib+mvS6SZ8vRRnTuiTTayHXwdk1KU50ZYXGTFn8Mr+ThRNfXKcDQcWtByFSk4SKrOXrGM57R3qVibMMlRG4FTjgfgKlzziDvlyGC7ZkwBMLQMUuSBAeqMNffPUXQLr744nYewF4EQl7TXZe/VbBkmx4PP7XXs88A+ShuH26EWnYjiLOWk0ZDKRkhUeBp/LW8UF9mED8VTn7mcpqkEZnI/5sgdWvFyBel9Pz+d2hO3SorG5Zi8LQCwa7AT/J8kHRPM4aOW43aSJ3Vz2UaWS/O9wJo+YQx1LONtVbkJpUZvwlH+P2vMTkZiAgNwY1Qh/r/+UF13kxB2JJsfkzoegVxPNBgMu1BVnCUk1EKYTfNMtJKnpYh+V8EfowI2CpsnLLnQd6TZ095reUR8q6WH2SEYLnZPB6PkB4+siDt/N4UworTtC7LrtztCjWykZYOBt8vfvGLm+KIny3F0PHIQCU6dWc4Z8SgsvKVI9Z/u+z4U5n95qI+roMg8Rh+5jsQEehQesfqhuKvIqRnJ5Tm/A4j6XH7tJdBA4E0ohwRRy4Y4Ue5ISOrPqww1W0Z+GdvYbsw6mEnQJTeKI8VlEDKp5IG6J0hPeNfGuKJqrdlkHfpkCmjEvljX7CjNjycKl5OEoaORwapQI2HUdFvDcgBGEKVLb05Mn2iKzONL7/ti8+OSISHNI51iL/aSNJwLrroojYXZydxGMvOS1OoyseihszddffiMiQ2nOff/g5pOZIdfzWcHpIbvykz820NxdZfm4uM1PTiadye4XtTRBGAfSiUgamPtBfl7WTC5i8GUVMIo56qmIJRuC3A0PHIgQDb+mvdmBDn02BZZ05PezIqsm+Q/rct2/4Awh7KsLm69VTfpYGF+nB6UduOTZccYiK8TvJRGFZnjKLCV76GJc6MmCgDxBDLjwZvr4KwhtJOl/rSlcZpWmNbtdOUPV+h8Ec5JJ+rgPJbvGwcdhBmbg+nuvElPR0Km48tzZmueFdRw20Rho5HBrU3s4PQjcQ2DJknazS2u56sChwJh9/40cD8tqbNOEW4IviQhtAjjaQ+Q3r5hF1G/Di6bBjv1ihzcY3MkiQ4wajcsumLAZY9xjKbMKZdFNgiCq/AJiEOFGWQkU5VgouQMEZ21v2VmbqElC3Ucj/ZUH8gXfLTK6jTxdcJxNDxyILBzLcFXcg62uE4CnMyIK300qD3dtFLtu8ijSmNPA3L70ppPIuwDjG4amTuATCVYcQES7mIYZDxEW0af++/hkneqhviTsFR3FYlbECLYj9d9TXCiJ8eo3BbgKHjkYcKOyxChg/PjCAsP5qL5/r39MrpYfNEaVSLsIooAXsi5J1NwggCL/Z5CM8e4H+bl9Cm8ff+qyKIooubp5EKo681f6sfUZzK6LAphSOMoeORxCJhWuR+KpH06+jBnF8PzSYQBVFpHev9OiRuNhWX09hVKW0bmCgftgJ8ZVl10/hX+eVu6mR/AduF4Xjm5z1SRhUjfzscN4aORxqEKb3zYRCy9ID1/yBuzkVYVWD8Y3lPg1qFdUljNELJyMCUglLILcb5OMqm8S/yLz6jIasxOcZc0ZfJETPkHXYMHXc4JBg1Ag3G8F7PahTBIh8jY08adobnI8rUhLHRVeiG7kYrnsiqhGW3Udw9SaOmFUXAzTkEn2GjZMSZ5bsYgiGKIPnc4fTgcpf92NEhp7mhXPbr05T/50Y3zQ1ruu51rzvd+MY3nm5605tON7nJTaZrX/va0zWucY3pqp9/1emss886JvzcXi/7NU2f+MQnWvif/MmfnB73uMdNF1xwQfv97ne/e5pHJ9M8r59udatbTc9//vOb/xq2xomPvU/tTZd8/JJpno5M80hgesMb3jC98Y1vbHj7298+/cM//MNlvj8dNhBnsKPTTzulsGWURpQGWRvS3NtOc6+8/+6LvuiLpi/+4i+e5uH5dIMb3KA94SpXucqnFcZVr9r8+v/CCy+c7nnPe07nnnvu9I53vGN6y5+9ZbronRdNN7zhDaef/umfnh71qEdNH/nIR6Z5ZDF97GMfm/7u7/5u+uhHPzq95z3vmf76r/+6NXrPv/qrv5re9773TXOv3xQFwlMIj3jOux0dPtophS0jvbrePaRRB7W3jWJA1R1psOLRQD2vdKUrNff3vve97Xn3u999etaznjU95znPab+vc53rtDCUwMc//vHWoPHQRgddeuEjv6WBKIadItgOOuuy5462hKpCQBqgxpZGFwXgdxqhxqlRQxqtHt9wXq9PGUQheHejG92o/X7Tm97Unu9617umiy66qI0OKIV//Md/bOnxW+OFngf8RoHsaDtopxSOOKWBBusQuwRiE1hFB4l/R4ebdkrhiFPfaINF9Nmf/dnNSKlnf8tb3tJ6/1D9HVo33h1tD+2Uwo6OoUsvvXT68Ic/PF188cX7U4odnVm0UwpnKC3q2bm97W1va6sJ7Ac7OvNopxR2dAxRCm9+85un1772tZe57OhMo51S2NExZCXBqsMrX/nK/RWF0MimsKOjR2p5Zx06g6lv6EYKNjN97ud+btuMRElkObH+3tHRpZ1SOMMpSiH2Bf9XW0N2SVII3Ou7HR1N2imFM5yiBPK81rWu1c5RWIWwJGlzk63RNjD1CmNHR5N2SuEMJw0dnJN4ylOeMn3lV37l9OxnP3u6whWuMN361rduft75zndOd7nLXXbThzOIKIUdzmC4bs13H1x2Mo8U9o8uu+fAJ+sde/6sBRef7HAkMXTc4QyCj8t88pOfbLcx+58CcBMT5eAK9de//vXtMtc+3A5HE7slyTOcTAnOOeec9rztbW473e9+92v2hBgXP/jBD04PfehDp0suuWT/xOOOjj4NtcUOZwbmht+ueUOuY0c+n+fjMPXr1/zVcDscaQwddziDoMH7aAxyfdunLrtCzcWwbnj2aXVTiXmkMAy/w5HD0HGHMwQaugbvYlifna/Xx1MKyPcffBBmFH6HI4mh4w5nCDICyCjAl6Ae+chHNuOiS11zsasvNO2mEGcMho47nCGgDHxdOl/f1vApCrjXve6195GPfKRNJ3xiz9e1+vA7HD3sVh/OcLIZ6c53vvP0fd/3fW0T06wkmvvlL3/5dk+jm52R1YfdUeozg3ZK4QyneWbQdiyef/750zWvec22HImyc/EDH/hA8/OHf/iHn3E/5I6OLg2HEDucOciSpK9K+1R/3H0Exm5GX5r2XcedTeHMwO7swxlOrni/3e1u17758Na3vnX67u/+7nbJihubb3nLW7ZbmEwtXM02K4Xd2YczgHZKYUft8BPl4F5GF7de73rXa09Th9zTuFMIZw7tlMIZToyLldgPdnRm087QuKMd7egY2imFHe1oR8fQTinsaEc7OoZ2NoUd7WhHx9BupLCjHe3oGNophR3taEfH0E4p7GhHOzqGdkphRzva0TG0Uwo72tGOCk3T/weulu4/8agWawAAAABJRU5ErkJggg==)

You receive the direction you are facing (one of the 8 directions: N, NE, E, SE, S, SW, W, NW) and a certain degree to turn (a multiple of 45, between -1080 and 1080); positive means clockwise, and negative means counter-clockwise.

Return the direction you will face after the turn.

Examples

"S",  180  -->  "N"

"SE", -45  -->  "E"

"W",  495  -->  "NE"
"""

#0
def direction(facing, turn):
    
    if turn > 360 or turn < -360:
        step = (turn % 360) // 45
    else:    
        step = turn // 45
        
    side = {0:'N', 45:'NE', 90:'E', 135:'SE', 180:'S', 225:'SW', 270:'W', 315:'NW', 360:'N'}
    comp = {'N':0, 'NE':45, 'E':90, 'SE':135, 'S':180, 'SW':225, 'W':270, 'NW':315}
    
    s = comp[facing]
    while step != 0:
        if step >0:
            if s == 360:
                s = 0
            step -= 1
            s += 45
        else:
            step += 1
            s -= 45
            if s == 0:
                s = 360
    return side[s]

#1
DIRECTIONS = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']


def direction(facing, turn):
    return DIRECTIONS[(turn // 45 + DIRECTIONS.index(facing)) % 8]

#2
direction = lambda f, t: (D:=['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'])[(D.index(f)*45+t)//45%8]

#3
degToCompass = {
    0: "N",
    45: "NE",
    90: "E",
    135: "SE",
    180: "S",
    225: "SW",
    270: "W",
    315: "NW",
}

compassToDeg = {
    "N": 0,
    "NE": 45,
    "E": 90,
    "SE": 135,
    "S": 180,
    "SW": 225,
    "W": 270,
    "NW": 315,
}

def direction(facing, turn):
    return degToCompass[(compassToDeg[facing] + turn) % 360]

"""# Задача 335(7) Narcissistic Numbers

A Narcissistic Number is a number of length n in which the sum of its digits to the power of n is equal to the original number. If this seems confusing, refer to the example below.

Ex: 153, where n = 3 (number of digits in 153)
13 + 53 + 33 = 153

Write a method is_narcissistic(i) (in Haskell: isNarcissistic :: Integer -> Bool) which returns whether or not i is a Narcissistic Number.
"""

#0
def is_narcissistic(i):
    s = list(map(int, str(i)))
    return i == sum([i**len(s) for i in s])

"""# Задача 336(7) Simple string characters

In this Kata, you will be given a string and your task will be to return a list of ints detailing the count of uppercase letters, lowercase, numbers and special characters, as follows.

Solve("*'&ABCDabcde12345") = [4,5,5,3]. 

--the order is: uppercase letters, lowercase, numbers and special characters.
More examples in the test cases.

Good luck!
"""

#0
import string

def solve(s):
    
    r1, r2, r3, r4 = 0, 0, 0, 0
    
    for i in s:
        if i in string.ascii_uppercase:
            r1 += 1
        elif i in string.ascii_lowercase:
            r2 += 1
        elif i in string.digits:
            r3 += 1
        elif i in string.punctuation:
            r4 += 1
        
    return [r1,r2,r3,r4]

#1
def solve(s):
  uc, lc, num, sp = 0, 0, 0, 0
  for ch in s:
    if ch.isupper(): uc += 1
    elif ch.islower(): lc += 1
    elif ch.isdigit(): num += 1
    else: sp += 1
  return [uc, lc, num, sp]

#2
import re
def solve(s):
    return [len(re.findall(i,s)) for i in ('[A-Z]','[a-z]','\d','[^a-zA-Z0-9]')]

#3
import re
def solve(s):
    uppercase = len(re.findall('[A-Z]', s))
    lowercase = len(re.findall('[a-z]', s))
    numbers = len(re.findall('[0-9]', s))
    special = len(re.findall('[^A-Za-z0-9]', s))
    return [uppercase, lowercase, numbers, special]

"""# Задача 337(7) Categorize New Member

The Western Suburbs Croquet Club has two categories of membership, Senior and Open. They would like your help with an application form that will tell prospective members which category they will be placed.

To be a senior, a member must be at least 55 years old and have a handicap greater than 7. In this croquet club, handicaps range from -2 to +26; the better the player the lower the handicap.

Input

Input will consist of a list of pairs. Each pair contains information for a single potential member. Information consists of an integer for the person's age and an integer for the person's handicap.

Output

Output will consist of a list of string values (in Haskell and C: Open or Senior) stating whether the respective member is to be placed in the senior or open category.

Example

input =  [[18, 20], [45, 2], [61, 12], [37, 6], [21, 21], [78, 9]]

output = ["Open", "Open", "Senior", "Open", "Open", "Senior"]


open_or_senior([(45, 12),(55,21),(19, -2),(104, 20)]),

['Open', 'Senior', 'Open', 'Senior'])

open_or_senior([(16, 23),(73,1),(56, 20),(1, -1)]),

['Open', 'Open', 'Senior', 'Open'])
"""

#0
def open_or_senior(data):
    lst = []
    for i in data:
        if i[0] >= 55 and i[1] > 7:
            lst.append('Senior')
        else:
            lst.append('Open')
    return lst

#1
def open_or_senior(data):
    return ['Senior' if i[0] >= 55 and i[1] > 7 else 'Open' for i in data]

"""# Задача 338(7) You Got Change?

Create a function that will take any amount of money and break it down to the smallest number of bills as possible. Only integer amounts will be input, NO floats. This function should output a sequence, where each element in the array represents the amount of a certain bill type. The array will be set up in this manner:

array[0] ---> represents $1 bills

array[1] ---> represents $5 bills

array[2] ---> represents $10 bills

array[3] ---> represents $20 bills

array[4] ---> represents $50 bills

array[5] ---> represents $100 bills

In the case below, we broke up $365 into 1 $5 bill, 1 $10 bill, 1 $50 bill, and 3 $100 bills.

give_change(365) # =>  (0,1,1,0,1,3)
In this next case, we broke $217 into 2 $1 bills, 1 $5 bill, 1 $10 bill, and 2 $100 bills.

give_change(217) # => (2,1,1,0,0,2)
"""

#0
def give_change(amount): 
    lst = []
    
    if amount >= 100:
        bills_100 = amount // 100
        amount -= bills_100 * 100
    else:
        bills_100 = 0
        
    if amount >= 50:
        bills_50 = amount // 50
        amount -= bills_50 * 50
    else:
        bills_50 = 0
        
    
    if amount >= 20:
        bills_20 = amount // 20
        amount -= bills_20 * 20
    else:
        bills_20 = 0
        
    
    if amount >= 10:
        bills_10 = amount // 10
        amount -= bills_10 * 10
    else:
        bills_10 = 0
        
    
    if amount >= 5:
        bills_5 = amount // 5
        amount -= bills_5 * 5
    else:
        bills_5 = 0
        
    lst.append(amount)
    lst.append(bills_5)
    lst.append(bills_10)
    lst.append(bills_20)
    lst.append(bills_50)
    lst.append(bills_100)
    
    return tuple(lst)

#1
def give_change( money ):
    arr = []
    for i in [100, 50, 20, 10, 5, 1]:
        arr = [money // i] + arr
        money -= arr[0] * i
    return tuple(arr)

#2
def give_change(amount): 
    r = []
    for c in (100, 50, 20, 10, 5, 1):
        d, amount = divmod(amount, c)
        r.append(d)
    return tuple(reversed(r))

"""# Задача 339(8) Merge two sorted arrays into one

You are given two sorted arrays that both only contain integers. Your task is to find a way to merge them into a single one, sorted in asc order. Complete the function mergeArrays(arr1, arr2), where arr1 and arr2 are the original sorted arrays.

You don't need to worry about validation, since arr1 and arr2 must be arrays with 0 or more Integers. If both arr1 and arr2 are empty, then just return an empty array.

Note: arr1 and arr2 may be sorted in different orders. Also arr1 and arr2 may have same integers. Remove duplicated in the returned result.

Examples (input -> output)

* [1, 2, 3, 4, 5], [6, 7, 8, 9, 10] -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

* [1, 3, 5, 7, 9], [10, 8, 6, 4, 2] -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

* [1, 3, 5, 7, 9, 11, 12], [1, 2, 3, 4, 5, 10, 12] -> [1, 2, 3, 4, 5, 7, 9, 10, 11, 12]

Happy coding!
"""

#0
def merge_arrays(arr1, arr2):
    arr = set(arr1 + arr2)
    arr = sorted(arr)
    return list(arr)

#1
def merge_arrays(arr1, arr2):
    return sorted(set(arr1+arr2))

#2
merge_arrays = lambda a, b: sorted(list(set(a + b)))

#3
def merge_arrays(arr1, arr2):
    return sorted(set(arr1) | set(arr2))

"""# Задача 340(8) Hello, Name or World!

Define a method hello that returns "Hello, Name!" to a given name, or says Hello, World! if name is not given (or passed as an empty String).

Assuming that name is a String and it checks for user typos to return a name with a first capital letter (Xxxx).

Examples:

* With `name` = "john"  => return "Hello, John!"

* With `name` = "aliCE" => return "Hello, Alice!"

* With `name` not given 

  or `name` = ""        => return "Hello, World!"
"""

#0
def hello(name=''):
    if name:
        return f"Hello, {name.title()}!"
    else:
        return "Hello, World!"

#1
def hello(name=''):
    return f"Hello, {name.title()}!" if name else "Hello, World!"

#2
def hello(name=''):
    return f"Hello, {name.title() or 'World'}!"

#3
def hello(name=''):
    return "Hello, {}!".format(name.title() if name else 'World')

"""# Задача 341(7) Zero And One

You have a string that consists of zeroes and ones. Now choose any two adjacent positions in the string: if one of them is 0, and the other one is 1, remove these two digits from the string.

Return the length of the resulting (smallest) string that you can get after applying this operation multiple times?

Note: after each operation, the remaining digits are separated by spaces and thus not adjacent anymore - see the examples below.

Examples

For "01010" the result should be 1:

"01010"  -->  "  010"  -->  "    0"

For "110100" the result should be 2:

"110100"  -->  "1  100"  -->  "1    0"

Input/Output

[input] string s

The initial string.

[output] an integer

The minimum length of the string that may remain after applying the described operations as many times as possible.
"""

#0
def zero_and_one(s):
    while "01" in s or "10" in s:
        for i,item in enumerate(s):
            if i < len(s):
                if s[i]=='1' and s[i+1]=='0':
                    s = s.replace("10", " ",1)
                    break
                elif s[i]=='0' and s[i+1]=='1':
                    s = s.replace("01", " ",1)
                    break
                
    
    s = s.replace(" ", "")
    return len(s)

#1
import re

def zero_and_one(s):
    return len(re.sub("01|10", "", s))

#2
def zero_and_one(s): 
  return len(s.replace('01', '').replace('10', ''))

"""# Задача 342(7) Kill The Monsters!

Description
You are Saitama (a.k.a One Punch Man), and you are fighting against the monsters! You are strong enough to kill them with one punch, but after you punch 3 times, one of the remaining monsters will hit you once.

Your health is health; number of monsters is monsters, damage that monster can give you is damage.

Task
Write a function that will calculate:

how many hits you received, how much damage you received and your remaining health.

if your health is <= 0, you die and function should return "hero died".

Examples

(100, 3, 33)  => "hits: 0, damage: 0, health: 100"

( 50, 7, 10)  => "hits: 2, damage: 20, health: 30"

Note

All numbers are strictly positive. Your function should always return a string.

Have fun :)
"""

#0
def kill_monsters(health, monsters, damage):
    hits = monsters//3
    if monsters % 3 == 0:
        hits -= 1
    health -= hits * damage
    if health <=0:
        return "hero died"
    damage *= hits
    return f"hits: {hits}, damage: {damage}, health: {health}"

#1
def kill_monsters(health, monsters, damage):
    hits = (monsters - 1) // 3
    damage *= hits
    health -= damage
    return f'hits: {hits}, damage: {damage}, health: {health}' if health > 0 else 'hero died'

"""# Задача 343(7) Round up to the next multiple of 5

Given an integer as input, can you round it to the next (meaning, "higher") multiple of 5?

Examples:

input:    output:
0    ->   0
2    ->   5
3    ->   5
12   ->   15
21   ->   25
30   ->   30
-2   ->   0
-5   ->   -5
etc.
Input may be any positive or negative integer (including 0).

You can assume that all inputs are valid integers.
"""

#0
def round_to_next5(n):
    if n % 5 == 0:
        return n
    a = n // 5
    f = 5 * (a+1)
    return f

#1
def round_to_next5(n):
    if n % 5 == 0:
        return n
    a = n // 5
    f = 5 * (a+1)
    return f

#2
def round_to_next5(n):
    while n%5!=0:
        n+=1
    return n

#3
import math

def round_to_next5(n):
    # Your code here
    return math.ceil(n/5.0) * 5

"""# Задача 343(7)  Prostate cancer recurrence rates (ASTRO)

Although its use in screening healthy patients is debatable, Prostate Specific Antigen (PSA) is a very useful blood test for following the response of prostate cancer to treatment.

For patients treated with radiation therapy alone for prostate cancer, the PSA tends to take 2-3 years to reach a minimum value (nadir). If the PSA begins to rise again after the nadir value, this may represent a recurrence of prostate cancer.

The 1996 ASTRO (American Society for Radiation Oncology) definition (1) of a biochemical recurrence is: 3 consecutive rising PSA values after reaching the nadir value (lowest point) of the sample.

You are given a list of PSA values for one patient. The list consists of 12 PSA values in ng/mL (as a float with 2 decimal places) each taken 6 months apart. The first value is taken immediately before treatment. The accuracy is two decimal points. The nadir (minimum value) will appear only once in the list.

Return True if the values meet the ASTRO criteria (3 consecutive increases in PSA occuring any time after reaching the lowest value) or False if they do not.

For clarity, the 3 consecutive increases may start directly from the nadir but do not have to. See examples below.

Examples:

Input:
[7.91, 2.43, 1.49, 0.99, 0.74, 0.48, 0.52, 0.50, 0.66, 1.26, 1.36, 1.35]
Ouput:
True
# Nadir 0.48,  3 subsequent rises: 0.50->0.66, 0.66->1.26 , 1.26->1.36

Input:
[9.98, 8.56, 4.62, 1.16, 0.26, 0.37, 0.32, 1.02, 0.99, 1.56, 1.41, 2.35]
Ouput:
False
# Nadir 0.26. No subsequent sequence of 3 consecutive rises. 

Input:
[12.57, 6.86, 1.86, 1.93, 0.60, 1.26, 0.99 ,2.1, 0.70, 0.72, 0.88, 1.9]
Output:
True
# Nadir 0.60, 3 subsequent consecutive rises: 0.70->0.72, 0.72->0.88, 0.88->1.9

Input:
[14.66, 3.14, 0.53, 0.58, 1.00, 1.26, 0.99 ,2.1, 1.50, 2.53, 2.17, 2.50]
Output:
True
# Nadir 0.53.  3 subsequent consecutive rises: 0.53->0.58, 0.58->1.00, 1.00-> 1.26
(1) Cox J, Grignon D, Kaplan R, Parsons J, Schellhammer P. Consensus statement: guidelines for PSA following radiation therapy. Int J Radiat Oncol Biol Phys. 1997;37:1035– 1041.
"""

#0
def recurrence(values):
    min_val = min(values)
    min_index = values.index(min_val)
    s = 0
    for i in range(min_index, len(values)-1):
        i_min = values[i]
        if values[i+1] > i_min:
            s += 1
        if values[i+1] <= i_min and s < 3:
            s = 0
    
    return s >= 3

#1
def recurrence(values):
    s = 0
    for i in range(values.index(min(values)), len(values)-1):
        i_min = values[i]
        if values[i+1] > i_min:
            s += 1
        if values[i+1] <= i_min and s < 3:
            s = 0
    
    return s >= 3

"""# Задача 344(7) Find all pairs:

Notes:

Array can be empty or contain only one value; in this case return 0
If there are more pairs of a certain number, count each pair only once. E.g.: for [0, 0, 0, 0] the return value is 2 (= 2 pairs of 0s)
Random tests: maximum array length is 1000, range of values in array is between 0 and 1000

Examples

[1, 2, 5, 6, 5, 2]  -->  2

...because there are 2 pairs: 2 and 5

[1, 2, 2, 20, 6, 20, 2, 6, 2]  -->  4

...because there are 4 pairs: 2, 20, 6 and 2 (again)
"""

#0
def duplicates(arr):
    
    if len(arr) <= 1:
        return 0
    
    count = 0
    
    while len(arr) > 1:
        if arr[0] in arr[1:]:
            idx = arr[1:].index(arr[0])
            count += 1
            del arr[idx+1]
        
        arr = arr[1:]
            
    return count

#1
def duplicates(arr):
    return sum(arr.count(i)//2 for i in set(arr))

#2
def duplicates(arr):
    uniques = set(arr)
    pairs = 0
    for i in uniques:
        pairs = pairs + (arr.count(i)//2)
    return pairs

"""# Задача 345 (7)  Odd March Bits 8 bits

Odd bits are getting ready for Bits Battles.

Therefore the n bits march from right to left along an 8 bits path. Once the most-significant bit reaches the left their march is done. Each step will be saved as an array of 8 integers.

Return an array of all the steps.

1 <= n <= 8

NOTE: n != 0, because n represents the number of 1s.

Examples
This resembles a simple 8 LED chaser:

n = 3

00000111
00001110
00011100
00111000
01110000
11100000


n = 7

01111111
11111110
"""

#0
def bit_march(n):
    res = []
    position = 7 - n
    for i in range(9-n):
        append_list = [1 if position < x < position + n + 1 else 0 for x in range(8)]
        position -= 1
        res.append(append_list)
    return res

#1
def bit_march (n : int) -> list:
    a = []
    for i in range(9-n):
        r = [0]*8
        for x in range(n):
            r[7-i-x] = 1
        print(r)
        a.append(r)
    return a

"""# Задача 346(7) Strange mathematics

So, for example, if n = 11, then the numbers in strange mathematics are ordered as follows:

1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9.

Help your students to learn this science: write a function that receives two integer numbers: n (total amount of numbers in strange mathematics) and k (number from sequence) and returns the location of a given number k in the order defined in strange mathematics.

For example, if n = 11 and k = 2, the function should return 4 as the answer.

Input: 1 <= n <= 100 000 , 1 <= k <= n.

Output: position of the number k in sequence of the first n natural numbers in lexicographic order. Numbering starts with 1.

Examples:

strange_math(11, 2) == 4

strange_math(15, 5) == 11

strange_math(15, 15) == 7
"""

#0
def strange_math(n, k):
    return sorted(map(str,range(1,n+1))).index(str(k))+1

#1
def strange_math(n, k):
    return sorted(range(n+1), key=str).index(k)

#2
strange_math = lambda n, k: sorted(str(x) for x in range(1,n+1)).index(str(k))+1

"""# Задача 347(8) Sum of differences in array

Your task is to sum the differences between consecutive pairs in the array in descending order.

Example
[2, 1, 10]  -->  9
In descending order: [10, 2, 1]

Sum: (10 - 2) + (2 - 1) = 8 + 1 = 9

If the array is empty or the array has only one element the result should be 0 (Nothing in Haskell ).
"""

#0
def sum_of_differences(arr):
    arr.sort(reverse=True)
    s = 0
    for i in list(zip(arr, arr[1:])):
        s += i[0] - i[1]
    return s

#1
def sum_of_differences(arr):
    return max(arr) - min(arr) if arr else 0

#2
def sum_of_differences(arr):
    arr = sorted(arr, reverse=True)
    return sum(a - b for a, b in zip(arr, arr[1:]))

"""# Задача 348(7) he Robber Language

Introduction
The Robber Language (Rövarspråket) is a Swedish cant used by children to mislead people not familiar with the language. It's used by kids in several screenplays created by Astrid Lindgren.

The idea is that every consonant in a sentence is duplicated, with an o inserted in between (b becomes bob). Vowels are left untouched (a remains an a). It's quite hard for an untrained ear to understand a conversation encoded in this manner, especially if spoken rapidly.

Example
In this example, the consonants f, b and r are modified. The vowels o and a are left untouched.

'foo bar' => 'fofoo bobaror' (`fof-o-o bob-a-ror`)
Note: The dashes - in the example are added for readability and should not be included in the output.

The Assignment
Your task is to implement a function def robber_encode(sentence) which takes in a string sentence and returns the result converted into robber language.

Notes
Only consonants should be modified; leave all other characters unchanged.
Both upper and lower case characters will be tested.
The case of the o character and the neighboring consonants should match (F => FOF and f => fof).
For the purpose of this kata, a character is considered a consonant if it's equal to one of the letters BCDFGHJKLMNPQRSTVWXYZ.
Testing
The tests will challenge your function with sentences of length 0-255, ASCII characters between 32-126 and nothing else.

Links
Check out these links for more information:

# Задача 349(7) Coding Meetup #5 - Higher-Order Functions Series - Prepare the count of languages

You will be given an array of objects (associative arrays in PHP, table in COBOL) representing data about developers who have signed up to attend the next coding meetup that you are organising.

Your task is to return an object (associative array in PHP, table in COBOL) which includes the count of each coding language represented at the meetup.

For example, given the following input array:

list1 = [
    { 'firstName': 'Noah', 'lastName': 'M.', 'country': 'Switzerland', 'continent': 'Europe', 'age': 19, 'language': 'C' },

    { 'firstName': 'Anna', 'lastName': 'R.', 'country': 'Liechtenstein', 'continent': 'Europe', 'age': 52, 'language': 'JavaScript' },

    { 'firstName': 'Ramon', 'lastName': 'R.', 'country': 'Paraguay', 'continent': 'Americas', 'age': 29, 'language': 'Ruby' },

    { 'firstName': 'George', 'lastName': 'B.', 'country': 'England', 'continent': 'Europe', 'age': 81, 'language': 'C' },
    ]
your function should return the following object (associative array in PHP, table in COBOL):

{ 'C': 2, 'JavaScript': 1, 'Ruby': 1 }

Notes:

The order of the languages in the object does not matter.
The count value should be a valid number.
The input array will always be valid and formatted as in the example above.
"""

#0
from collections import Counter
def count_languages(lst): 
    programm = []
    for i in lst:
        programm.append(i.get('language'))
    return Counter(programm)
  
#1
from collections import Counter
def count_languages(lst): 
    programm = [i.get('language') for i in lst]
    return Counter(programm)

#2
from collections import Counter
def count_languages(lst): 
    return Counter([i.get('language') for i in lst])

#3
def count_languages(lst): 
    language = [el['language'] for el in lst]
    return {i: language.count(i) for i in language}

"""# Задача 350(7) Coprime Validator

Write a program to determine if the two given numbers are coprime. A pair of numbers are coprime if their greatest shared factor is 1.

The inputs will always be two positive integers between 2 and 99.

Examples

20 and 27:

Factors of 20: 1, 2, 4, 5, 10, 20

Factors of 27: 1, 3, 9, 27

Greatest shared factor: 1

Result: 20 and 27 are coprime

12 and 39:

Factors of 12: 1, 2, 3, 4, 6, 12

Factors of 39: 1, 3, 13, 39

Greatest shared factor: 3

Result: 12 and 39 are not coprimes
"""

#0 
def are_coprime(n,m):
    lst1 = [i for i in range(1,n+1) if n % i == 0]
    lst2 = [i for i in range(1,m+1) if m % i == 0]
    if len(lst1) < len(lst2):
        for i, item in enumerate(lst1):
            if item in lst2 and lst1[i] != 1:
                return False
        return True
    else:
        for i, item in enumerate(lst2):
            if item in lst1 and lst2[i] != 1:
                return False
        return True

#1
from fractions import gcd

def are_coprime(n, m):
  return gcd(n, m) == 1

#2
def are_coprime(n, m):
    # All hail Euclid and his wonderful algorithm
    while m > 0:
        n, m = m, n % m
    return n == 1

#3
def are_coprime(x,y):
    arrX = [i for i in range(1, x + 1) if x % i == 0]
    arrY = [i for i in range(1, y + 1) if y % i == 0]
    return len(list(set(arrX) & set(arrY))) == 1

#4
def are_coprime(n,m):
    if m <2 : return m==1
    return are_coprime(m,n%m)

"""# Задача 351(7) Ce*s*r*d Strings

Fortunately, I discovered that the virus hides my censored letters inside root directory.

It will be very tedious to recover all these files manually, so your goal is to implement uncensor function that does the hard work automatically.

Examples
uncensor("*h*s *s v*ry *tr*ng*", "Tiiesae") ➜ "This is very strange"

uncensor("A**Z*N*", "MAIG") ➜ "AMAZING"

uncensor("xyz", "") ➜ "xyz"

Notes

Expect all discovered letters to be given in the correct order.
Discovered letters will match the number of censored ones.
Any character can be censored.
"""

#0
def uncensor(infected, discovered):
    if  discovered == '':
        return infected
    s = ''
    for i in infected:
        if i =='*':
            s += discovered[0]
            discovered = discovered[1:]
        else:
            s += i
    return s

#1
def uncensor(infected, discovered):
    return infected.replace('*', '{}').format(*discovered)
  
#2
def uncensor(s, sub):
    it=iter(sub)
    return ''.join( c if c!='*' else next(it) for c in s )

#3
from re import sub

def uncensor(infected, discovered):
    it = iter(discovered)
    return sub(r"\*", lambda _:next(it), infected)

#4
def uncensor(infected, discovered):
    for letter in discovered:
        infected = infected.replace('*',letter,1)
    return infected

"""# Задача 352(7) Strong Number (Special Numbers Series #2)

Definition
Strong number is the number that the sum of the factorial of its digits is equal to number itself.

For example, 145 is strong, since 1! + 4! + 5! = 1 + 24 + 120 = 145.

Task

Given a number, Find if it is Strong or not and return either "STRONG!!!!" or "Not Strong !!".

Notes

Number passed is always Positive.
Return the result as String
Input >> Output Examples
strong_num(1) ==> return "STRONG!!!!"
Since, the sum of its digits' factorial (1) is equal to number itself, then its a Strong.

strong_num(123) ==> return "Not Strong !!"
Since the sum of its digits' factorial of 1! + 2! + 3! = 9 is not equal to number itself, then it's Not Strong .

strong_num(2)  ==>  return "STRONG!!!!"
Since the sum of its digits' factorial of 2! = 2 is equal to number itself, then its a Strong.

strong_num(150) ==> return "Not Strong !!"
Since the sum of its digits' factorial of 1! + 5! + 0! = 122 is not equal to number itself, Then it's Not Strong .
"""

#0
from math import factorial

def strong_num(number):
    lst = [i for i in str(number)]
    sum  = 0
    for i in lst:
        sum += factorial(int(i))
    return "STRONG!!!!" if number == sum else "Not Strong !!"

#1
from math import factorial

def strong_num(number):
    return "STRONG!!!!" if number == sum([factorial(int(i)) for i in [i for i in str(number)]]) else "Not Strong !!"

#2
from math import factorial
def strong_num(number):
  return ("Not Strong !!", "STRONG!!!!")[sum(factorial(int(i)) for i in str(number)) == number]

"""# Задача 353(7) Odd-Even String Sort

Given a string s. You have to return another string such that even-indexed and odd-indexed characters of s are grouped and groups are space-separated (see sample below)

Note: 
0 is considered to be an even index. 
All input strings are valid with no spaces
input: 'CodeWars'
output 'CdWr oeas'

S[0] = 'C'
S[1] = 'o'
S[2] = 'd'
S[3] = 'e'
S[4] = 'W'
S[5] = 'a'
S[6] = 'r'
S[7] = 's'
Even indices 0, 2, 4, 6, so we have 'CdWr' as the first group
odd ones are 1, 3, 5, 7, so the second group is 'oeas'
And the final string to return is 'Cdwr oeas'
"""

#0
def sort_my_string(s):
    s1 = "".join([item for i, item in enumerate(s) if i % 2 == 0])
    s2 = "".join([item for i, item in enumerate(s) if i % 2 != 0])
    return s1 + " " +  s2

#1
def sort_my_string(s):
    return '{} {}'.format(s[::2], s[1::2])
  
#2
def sort_my_string(s):
    return s[::2] + ' ' + s[1::2]

#3
sort_my_string = lambda w: w[::2] +' '+ w[1::2]

"""# Задача 354(7) Scrabble Score

Write a program that, given a word, computes the scrabble score for that word.

Letter Values
You'll need these:

Letter                           Value
A, E, I, O, U, L, N, R, S, T       1
D, G                               2
B, C, M, P                         3
F, H, V, W, Y                      4
K                                  5
J, X                               8
Q, Z                               10
There will be a preloaded dictionary dict_scores with all these values: dict_scores["E"] == 1

Examples
"cabbage" --> 14
"cabbage" should be scored as worth 14 points:

3 points for C
1 point for A, twice
3 points for B, twice
2 points for G
1 point for E
And to total:

3 + 2*1 + 2*3 + 2 + 1 = 3 + 2 + 6 + 3 = 14

Empty string should return 0. The string can contain spaces and letters (upper and lower case), you should calculate the scrabble score only of the letters in that string.

""           --> 0
"STREET"    --> 6
"st re et"    --> 6
"ca bba g  e" --> 14
"""

#0
def scrabble_score(st):
    sum = 0
    st = st.upper().replace(" ","")
    for i in st:
        sum += dict_scores.get(i, 0)
    return sum

#1
def scrabble_score(st):
    return sum([dict_scores.get(i, 0) for i in st.upper()])

"""# Задача 355(7) The Office I - Outed

Your colleagues have been looking over you shoulder. When you should have been doing your boring real job, you've been using the work computers to smash in endless hours of codewars.

In a team meeting, a terrible, awful person declares to the group that you aren't working. You're in trouble. You quickly have to gauge the feeling in the room to decide whether or not you should gather your things and leave.

Given an object (meet) containing team member names as keys, and their happiness rating out of 10 as the value, you need to assess the overall happiness rating of the group. If <= 5, return 'Get Out Now!'. Else return 'Nice Work Champ!'.

Happiness rating will be total score / number of people in the room.

Note that your boss is in the room (boss), their score is worth double it's face value (but they are still just one person!).
"""

#0
def outed(meet, boss):
    sum = 0
    for i in meet:
        if i == boss:
            sum += meet.get(i,0) * 2
        else:
            sum += meet.get(i,0)
    mean = sum / len(meet)
    return 'Get Out Now!' if mean <= 5 else 'Nice Work Champ!'

#1
def outed(meet, boss):
    total = sum([meet.get(i,0) if i!=boss else meet.get(i,0) * 2 for i in meet ]) / len(meet)
    return 'Get Out Now!' if total <= 5 else 'Nice Work Champ!'

#2
def outed(meet, boss):
    return 'Get Out Now!' if (sum(meet.values()) + meet[boss] ) / len(meet) <= 5 else 'Nice Work Champ!'

"""# Задача 355(7) ATM

An ATM has banknotes of nominal values 10, 20, 50, 100, 200 and 500 dollars. You can consider that there is a large enough supply of each of these banknotes.

You have to write the ATM's function that determines the minimal number of banknotes needed to honor a withdrawal of n dollars, with 1 <= n <= 1500.

Return that number, or -1 if it is impossible.

Good Luck!!!
"""

#0
def solve(n):
    
    s = 0
    
    if n >= 500:
        while n >= 500:
            n = n - 500
            s += 1
    
    if n >= 200:
        while n >= 200:
            n = n - 200
            s += 1
        
    if n >= 100:
        while n >= 100:
            n = n - 100
            s += 1

    if n >= 50:
        while n >= 50:
            n = n - 50
            s += 1
         
    if n >= 20:
        while n >= 20:
            n = n - 20
            s += 1

    if n >= 10:
        while n >= 10:
            n = n - 10
            s += 1

    return s if n == 0 else -1

#1
def solve(n):
    if n%10: return -1
    c, billet = 0, iter((500,200,100,50,20,10))
    while n:
        x, r = divmod(n, next(billet))
        c, n = c+x, r
    return c

#2
def solve(n, cnt=0):    
    if n%10: return -1
    for i in (500,200,100,50,20,10):
        cnt += n//i
        n = n%i
    return cnt

#3
def solve(n):
    t=0
    for d in [500,200,100,50,20,10]:
        a,n=divmod(n,d)
        t+=a
    if n: return -1
    return t

"""# Задача 356(7) Switcheroo:

Given a string made up of letters a, b, and/or c, switch the position of letters a and b (change a to b and vice versa). Leave any incidence of c untouched.

Example:

'acb' --> 'bca'
'aabacbaa' --> 'bbabcabb'
"""

#0 
def switcheroo(s):
    s1 = ''
    for i in s:
        if i == 'a':
            s1 += 'b'
        if i == 'b':
            s1 += 'a'
        if i == 'c':
            s1 += 'c'
    return s1

#1
def switcheroo(s):
    s1 = ''
    for i in s:
        if i != 'a' and i != 'b':
            s1 += 'c'
        else:
            if i == 'a':
                s1 += 'b'
            else:
                s1 += 'a'
    return s1

#2
def switcheroo(string):
    return ((string.replace('a','x')).replace('b','a')).replace('x','b')

#3
def switcheroo(s):
    return s.translate(str.maketrans('ab','ba'))

#4
switcheroo = lambda q: q.translate({97: 98, 98: 97})

#5
def switcheroo(string):
    return ''.join({'a':'b', 'b':'a'}.get(c, c) for c in string)

#6
def switcheroo(string):
    return ''.join( [ 'a' if s=='b' else 'b' if s=='a' else s for s in string ] )

"""# Задача 357(7) Multiples By Permutations II

We have two consecutive integers k1 and k2, k2 = k1 + 1

We need to calculate the lowest strictly positive integer n, such that: the values nk1 and nk2 have the same digits but in different order.

E.g.# 1:

k1 = 100
k2 = 101
n = 8919

Because 8919 * 100 = 891900 
and      8919 * 101 = 900819


E.g.# 2:

k1 = 325
k2 = 326
n = 477

Because 477 * 325 = 155025
and      477 * 326 = 155502

Your task is to prepare a function that will receive the value of k and outputs the value of n.

The examples given above will be:

find_lowest_int(100) === 8919
find_lowest_int(325) ===  477
Features of the random tests

10 < k < 10.000.000.000.000.000 (For Python, Ruby and Haskell)
10 < k < 1.000.000.000  (For Javascript 1e9)
"""

#0
def find_lowest_int(k):
    k2 = k + 1
    n = 3
    while ''.join(sorted(str(n*k))) != ''.join(sorted(str(n*k2))):
        n += 1
    return n

"""Задача 358(7) Make acronym

Write function which takes a string and make an acronym of it.

Rule of making acronym in this kata:

split string to words by space char
take every first letter from word in given string
uppercase it
join them toghether
Eg:

Code wars -> C, w -> C W -> CW
"""

#0
def to_acronym(inp):
    return ''.join([i[0].upper() for i in inp.split()])

#1
to_acronym = lambda input: "".join(list(map(lambda x: x[0].upper(),input.split())))

#2
import re

def to_acronym(s):
    return ''.join(re.findall(r'\b(\w)', s)).upper()

"""# Задача 358(7) Collatz Conjecture Length

The Collatz Conjecture states that for any natural number n, if n is even, divide it by 2. If n is odd, multiply it by 3 and add 1. If you repeat the process continuously for n, n will eventually reach 1.

For example, if n = 20, the resulting sequence will be:

[ 20, 10, 5, 16, 8, 4, 2, 1 ]
Write a program that will output the length of the Collatz Conjecture for any given n.
In the example above, the output would be 8.

For more reading see: http://en.wikipedia.org/wiki/Collatz_conjecture
"""

#0
def collatz(n):
    lst = []
    while n != 1:
        if n % 2 == 0:
            n = n // 2
            lst.append(n)
        else:
            n = n * 3 + 1
            lst.append(n)
            
    return len(lst) + 1

#1
def collatz(n):
    return 1 if n == 1 else 1 + collatz(3 * n + 1 if n % 2 else n // 2)

#2
def collatz(n):
    count = 1
    while n > 1:
        if n % 2 == 0:
            n //= 2
            count += 1
        else:
            n = n * 3 + 1
            count += 1
    return count

"""# Задача 359(7) Rock Paper Scissors Lizard Spock

In this kata, your task is to implement an extended version of the famous rock-paper-scissors game. The rules are as follows:

Scissors cuts Paper
Paper covers Rock
Rock crushes Lizard
Lizard poisons Spock
Spock smashes Scissors
Scissors decapitates Lizard
Lizard eats Paper
Paper disproves Spock
Spock vaporizes Rock
Rock crushes Scissors
Task:
Given two values from the above game, return the Player result as "Player 1 Won!", "Player 2 Won!", or "Draw!".

Inputs
Values will be given as one of "rock", "paper", "scissors", "lizard", "spock".
"""

#0
def rpsls(pl1, pl2):
    
    if pl1 == pl2:
        return 'Draw!'
    
    dct1 = {
           'paper' : 'rock',
           'rock' :'lizard',
           'lizard' : 'spock',
           'spock' : 'scissors',
           'scissors' : 'lizard',
           }
    
    dct2 = {'scissors' : 'paper',
           'lizard' : 'paper',
           'paper' : 'spock',
           'spock' : 'rock',
           'rock' : 'scissors'}
    
    
    if dct1[pl1] == pl2:
        return 'Player 1 Won!'
    
    elif dct2[pl1] == pl2:
        return 'Player 1 Won!'
    else:
        return 'Player 2 Won!'

#1
ORDER = "rock lizard spock scissors paper spock rock scissors lizard paper rock"

def rpsls(p1, p2):
    return ( "Player 1 Won!" if f"{p1} {p2}" in ORDER
        else "Player 2 Won!" if f"{p2} {p1}" in ORDER
        else "Draw!" )


#2
def rpsls(a, b):
    dic = {'spock':'scissors rock',
          'scissors':'lizard paper',
          'paper':'spock rock',
          'rock':'lizard scissors',
          'lizard':'spock paper'}
    return 'Player 1 Won!' if b in dic[a] else
           'Player 2 Won!' if a in dic[b] else 'Draw!'

"""# Задача 360(7) Sum a list but ignore any duplicates

Please write a function that sums a list, but ignores any duplicate items in the list.

For instance, for the list [3, 4, 3, 6] , the function should return 10.
"""

#0
def sum_no_duplicates(l):
    s = 0
    for i in l:
        if l.count(i) == 1:
            s += i
    return s

#1
def sum_no_duplicates(l):
    return sum([i for i in l if l.count(i)==1])

#2
from collections import Counter

def sum_no_duplicates(l):
    return sum(k for k,v in Counter(l).items() if v == 1)

#3
def sum_no_duplicates(l):
    return sum(filter(lambda n: l.count(n) == 1, l))

"""# Задача 361(7) Race Ceremony

The national go-kart racing competition is taking place in your local town and you've been called for building the winners podium with the available wooden blocks. Thankfully you are in a wood-rich area, number of blocks are always at least 6.

Remember a classic racing podium have three platforms for first, second and third places. First place is the highest and second place is higher than third. Also notice that platforms are arranged as 2nd - 1st - 3rd.

The organizers want a podium that satisfies:

The first place platform has the minimum height possible
The second place platform has the closest height to first place
All platforms have heights greater than zero.
Task
Given the numbers of blocks available, return an array / tuple or another data structure depending on the language (refer sample tests) with the heights of 2nd, 1st, 3rd places platforms.

Examples (input -> output)
11 ->   [4, 5, 2]
6  ->   [2, 3, 1]
10 ->   [4, 5, 1]
"""

#0
from math import ceil

def race_podium(blocks):
    
    if blocks == 7:
        return (2,4,1)
    
    n2 = ceil(blocks / 3)
    
    n1 = n2 + 1
    
    n3 = blocks - n1 - n2

#1
def race_podium(blocks):
    if blocks == 7:
        return (2, 4, 1)
    second = blocks // 3 + (blocks % 3 != 0)
    first = second + 1
    third = blocks - first - second
    return (second, first, third)

"""# Задача 362(7) Method For Counting Total Occurence Of Specific Digits

We need a method in the List Class that may count specific digits from a given list of integers. This marked digits will be given in a second list. The method .count_spec_digits()/.countSpecDigits() will accept two arguments, a list of an uncertain amount of integers integers_lists/integersLists (and of an uncertain amount of digits, too) and a second list, digits_list/digitsList that has the specific digits to count which length cannot be be longer than 10 (It's obvious, we've got ten digits). The method will output a list of tuples, each tuple having two elements, the first one will be a digit to count, and second one, its corresponding total frequency in all the integers of the first list. This list of tuples should be ordered with the same order that the digits have in digitsList

Let's see some cases:

l = List()

integers_list =  [1, 1, 2 ,3 ,1 ,2 ,3 ,4]
digits_list = [1, 3]
l.count_spec_digits(integers_list, digits_list) == [(1, 3), (3, 2)]

integers_list = [-18, -31, 81, -19, 111, -888]
digits_list = [1, 8, 4]
l.count_spec_digits(integers_list, digits_list) == [(1, 7), (8, 5), (4, 0)]

integers_list = [-77, -65, 56, -79, 6666, 222]
digits_list = [1, 8, 4]
l.count_spec_digits(integers_list, digits_list) == [(1, 0), (8, 0), (4, 0)]
Enjoy it!!
"""

#0
class List(object):
    def count_spec_digits(self, integers_list, digits_list):
        lst_count = []
        str_integers = "".join(map(str, integers_list))
        for i in digits_list:
            lst_count.append(str_integers.count(str(i)))
        return list(zip(digits_list, lst_count))

#1
class List(object):
    def count_spec_digits(self, integers_list, digits_list):
        str_integers = "".join(map(str, integers_list))
        lst_count = [str_integers.count(str(i)) for i in digits_list]    
        return list(zip(digits_list, lst_count))

"""# Задача 363(7) Which section did you scroll to?

Your website is divided vertically in sections, and each can be of different size (height).
You need to establish the section index (starting at 0) you are at, given the scrollY and sizes of all sections.
Sections start with 0, so if first section is 200 high, it takes 0-199 "pixels" and second starts at 200.

Example:
With scrollY = 300 and sizes = [300,200,400,600,100]

the result will be 1 as it's the second section.

With scrollY = 1600 and size = [300,200,400,600,100]

the result will be -1 as it's past last section.

Given the scrollY integer (always non-negative) and an array of non-negative integers (with at least one element), calculate the index (starting at 0) or -1 if scrollY falls beyond last section (indication of an error).

test.assert_equals(get_section_id(299, [300, 200, 400, 600, 100]), 0)
test.assert_equals(get_section_id(300, [300, 200, 400, 600, 100]), 1)
test.assert_equals(get_section_id(1600, [300, 200, 400, 600, 100]), -1)
"""

#0
def get_section_id(scroll, sizes):
    
    if scroll >= sum(sizes):
        return -1
    
    count = 0
    s =  0
    
    for i in sizes:
        s += i
        if scroll < s:
            return count
        count += 1

#1
def get_section_id(scroll, sizes):
    c = 0
    for idx, s in enumerate(sizes):
        c += s
        if scroll < c: 
          return idx
    return -1

#2
from itertools import accumulate

def get_section_id(scroll, sizes):
    return next((i for i,x in enumerate(accumulate(sizes)) if x > scroll), -1)

#3
def get_section_id(scroll, sizes):
    where = 0
    for i in range(len(sizes)):
        where += sizes[i]
        if where > scroll:
            return i
    return -1

"""# Задача 364(7) Geometric Progression Sequence

In your class, you have started lessons about geometric progression. Since you are also a programmer, you have decided to write a function that will print first n elements of the sequence with the given constant r and first element a.

Result should be separated by comma and space.

Example
geometric_sequence_elements(2, 3, 5) == '2, 6, 18, 54, 162'

More info: https://en.wikipedia.org/wiki/Geometric_progression

test.assert_equals(geometric_sequence_elements(2, 3, 5), '2, 6, 18, 54, 162')

test.assert_equals(geometric_sequence_elements(2, 2, 10), '2, 4, 8, 16, 32, 64, 128, 256, 512, 1024')

test.assert_equals(geometric_sequence_elements(1, -2, 10), '1, -2, 4, -8, 16, -32, 64, -128, 256, -512')
"""

#0
def geometric_sequence_elements(a, r, n):
    count = 1
    lst = []
    lst.append(a)
    while count < n:
        lst.append(a * r)
        count += 1
        a *= r
    return ", ".join(map(str, lst))

#1
def geometric_sequence_elements(a, r, n):
    return ', '.join(str(a * r ** i) for i in xrange(n))

"""# Задача 365(7) Numbers Which Sum of Powers of Its Digits Is The Same Number"""

Not considering number 1, the integer 153 is the first integer having this property: the sum of the third-power of each of its digits is equal to 153. Take a look: 153 = 1³ + 5³ + 3³ = 1 + 125 + 27 = 153

The next number that experiments this particular behaviour is 370 with the same power.

Write the function eq_sum_powdig(), that finds the numbers below a given upper limit hMax (inclusive) that fulfills this property but with different exponents as the power for the digits.

eq_sum_powdig(hMax, exp): ----> sequence of numbers (sorted list) (Number one should not be considered).

Let's see some cases:

eq_sum_powdig(100, 2) ----> []

eq_sum_powdig(1000, 2) ----> []

eq_sum_powdig(200, 3) ----> [153]

eq_sum_powdig(370, 3) ----> [153, 370]
Enjoy it !!

#0
def eq_sum_powdig(hMax, exp):
    list_return = [] 
    for i in range(2, hMax+1):
        lst = [str(num) for num in str(i)]
        sum = 0
        for x in lst:
            sum += int(x) ** exp
        if sum == i:
            list_return.append(i)
    return list_return

#1
def eq_sum_powdig(hMax, exp):
    list_return = [] 
    for i in range(2, hMax+1):
        lst = [int(num) for num in str(i)]
        total = sum((x ** exp for x in lst))
        if total == i:
            list_return.append(i)
    return list_return

#2
def eq_sum_powdig(hMax, exp):
    list_return = [] 
    for i in range(2, hMax+1):
        total_sum = sum((int(num) ** exp for num in str(i)))
        if total_sum == i:
            list_return.append(i)
    return list_return

#3
def eq_sum_powdig(hMax, exp):
    return [i for i in xrange(2, hMax + 1) if i == sum(int(c) ** exp for c in str(i))]

"""# Задача 366(7) Split The Bill

It's tricky keeping track of who is owed what when spending money in a group. Write a function to balance the books.

The function should take one parameter: an object/dict with two or more name-value pairs which represent the members of the group and the amount spent by each.
The function should return an object/dict with the same names, showing how much money the members should pay or receive.
Further points:

The values should be positive numbers if the person should receive money from the group, negative numbers if they owe money to the group.
If value is a decimal, round to two decimal places.
Translations and comments (and upvotes!) welcome.

Example
3 friends go out together: A spends £20, B spends £15, and C spends £10. The function should return an object/dict showing that A should receive £5, B should receive £0, and C should pay £5.

group = {
    'A': 20, 
    'B': 15, 
    'C': 10
}

split_the_bill(group) # returns {'A': 5, 'B': 0, 'C': -5}
"""

#0
def split_the_bill(x):
    mean = round(sum(x.values()) / len(x), 2)
    dict_return = x.copy()
    for i in dict_return:
        dict_return[i] = round(dict_return[i] - mean, 2)
    return dict_return

#1
def split_the_bill(x):
    mean = round(sum(x.values()) / len(x), 2)
    dict_return = {}
    for i in x:
        dict_return[i] = round(x[i] - mean, 2)
    return dict_return

"""# Задача 367(7) Likes Vs Dislikes

Story
YouTube had a like and a dislike button, which allowed users to express their opinions about particular content. It was set up in such a way that you cannot like and dislike a video at the same time. There are two other interesting rules to be noted about the interface: Pressing a button, which is already active, will undo your press. If you press the like button after pressing the dislike button, the like button overwrites the previous "Dislike" state. The same is true for the other way round.

Task
Create a function that takes in a list of button inputs and returns the final state.

Examples
like_or_dislike([Dislike]) ➞ Dislike
like_or_dislike([Like, Like]) ➞ Nothing
like_or_dislike([Dislike, Like]) ➞ Like
like_or_dislike([Like, Dislike, Dislike]) ➞ Nothing
Notes
If no button is currently active, return Nothing.
If the list is empty, return Nothing.

like_or_dislike([Dislike]), Dislike

like_or_dislike([Like, Like]), Nothing

like_or_dislike([Dislike, Dislike]), Nothing

like_or_dislike([Like, Like, Like]), Like

like_or_dislike([Like, Dislike]), Dislike

ike_or_dislike([Dislike, Like]), Like

like_or_dislike([Like, Dislike, Dislike]), Nothing

like_or_dislike([Dislike, Like, Dislike]), Dislike

like_or_dislike([Like, Like, Dislike, Like, Like, Like, Like, Dislike])

like_or_dislike([]), Nothing, repr([]))
"""

#0
def like_or_dislike(lst):
    if len(lst) == 0:
        return 'Nothing'
    elif len(lst) == 1:
        return lst[0]
    
    flag = 0
    
    for i in lst:
        if i == 'Dislike':
            if flag == 0:
                flag = - 1
            elif flag == -1:
                flag = 0
            elif flag == 1:
                flag = -1
                
        elif i == 'Like':
            if flag == 0:
                flag = 1
            elif flag == 1:
                flag = 0
            elif flag == -1:
                flag = 1
    
    if flag == 1:
        return 'Like'
    elif flag == -1:
        return 'Dislike'
    else:
        return 'Nothing'

#1
def like_or_dislike(lst):
    current = 'Nothing'
    for i in lst:
        if i == current:
            current = "Nothing"
        else:
            current = i
    return current

#2
def like_or_dislike(lst, status="Nothing"):
    for click in lst:
        status = "Nothing" if click == status else click
    return status

"""Задача 368(7) Simple Fun #10: Range Bit Counting

Task
You are given two numbers a and b where 0 ≤ a ≤ b. Imagine you construct an array of all the integers from a to b inclusive. You need to count the number of 1s in the binary representations of all the numbers in the array.

Example
For a = 2 and b = 7, the output should be 11

Given a = 2 and b = 7 the array is: [2, 3, 4, 5, 6, 7]. Converting the numbers to binary, we get [10, 11, 100, 101, 110, 111], which contains 1 + 2 + 1 + 2 + 2 + 3 = 11 1s.

Input/Output
[input] integer a
Constraints: 0 ≤ a ≤ b.

[input] integer b
Constraints: a ≤ b ≤ 100.

[output] an integer
"""

#0
def range_bit_count(a, b):
    return "".join(list(bin(i) for i in range(a, b+1))).count('1')

#1
def range_bit_count(a, b):
    return sum(bin(i).count('1') for i in range(a, b+1))

"""# Задача 368(7) Sorting Dictionaries

Python dictionaries are inherently unsorted. So what do you do if you need to sort the contents of a dictionary?

Create a function that returns a sorted list of (key, value) tuples (Javascript: arrays of 2 items).

The list must be sorted by the value and be sorted largest to smallest.

Examples

sort_dict({3:1, 2:2, 1:3}) == [(1,3), (2,2), (3,1)]

sort_dict({1:2, 2:4, 3:6}) == [(3,6), (2,4), (1,2)]

sort_dict({1:5, 3:10, 2:2, 6:3, 8:8}), [(3,10), (8,8), (1,5), (6,3), (2,2)])
"""

#0
def sort_dict(d):
    d_sort = sorted(d, key=d.get, reverse=True)
    lst = []
    for i in d_sort:
        lst.append((i, d[i]))
    return lst

#1
def sort_dict(d):
  return sorted(d.items(), key=lambda x: x[1], reverse=True)

#2
def sort_dict(d):
  'return a sorted list of tuples from the dictionary'
  return sorted(d.items(), key=lambda x: -x[1])

"""# Задача 369(7) **Spoonerize Me**

A spoonerism is a spoken phrase in which the first letters of two of the words are swapped around, often with amusing results.

In its most basic form a spoonerism is a two word phrase in which only the first letters of each word are swapped:

"not picking" --> "pot nicking"

Your task is to create a function that takes a string of two words, separated by a space: words and returns a spoonerism of those words in a string, as in the above example. A "word" in the context of this kata can contain any of the letters A through Z in upper or lower case, and the numbers 0 to 9. Though spoonerisms are about letters in words in the domain of written and spoken language, numbers are included in the inputs for the random test cases and they require no special treatment.

NOTE: All input strings will contain only two words. Spoonerisms can be more complex. For example, three-word phrases in which the first letters of the first and last words are swapped: "pack of lies" --> "lack of pies" or more than one letter from a word is swapped: "flat battery --> "bat flattery" You are NOT expected to account for these, or any other nuances involved in spoonerisms.

Once you have completed this kata, a slightly more challenging take on the idea can be found here: http://www.codewars.com/kata/56dbed3a13c2f61ae3000bcd

spoonerize("nit picking"), "pit nicking")

spoonerize("wedding bells"), "bedding wells")

spoonerize("jelly beans"), "belly jeans")

spoonerize("pop corn"), "cop porn")
"""

#0
def spoonerize(words):
    lst = words.split()
    s1 = lst[1][0] + lst[0][1:]
    s2 = lst[0][0] + lst[1][1:]
    return s1 + " " + s2

#1
def spoonerize(words):
    a, b = words.split()
    return '{}{} {}{}'.format(b[0], a[1:], a[0], b[1:])

#2
def spoonerize(words):
    a, b = words.split()
    return f"{b[0]}{a[1:]} {a[0]}{b[1:]}"

#3
import re

def spoonerize(s):
    return re.sub("(.)(.+) (.)(.+)", r"\3\2 \1\4", s)

#4
import re
def spoonerize(words):
    s = re.finditer(r"\s", words)
    l = list(words)
    k = list(s)[-1].start()+1
    l[0], l[k] = l[k], l[0]
    return "".join(l)

"""# Задача 370(7) **Especially Joyful Numbers**

Positive integers that are divisible exactly by the sum of their digits are called Harshad numbers. The first few Harshad numbers are: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, ...

We are interested in Harshad numbers where the product of its digit sum s and s with the digits reversed, gives the original number n. For example consider number 1729:

its digit sum, s = 1 + 7 + 2 + 9 = 19

reversing s = 91

and 19 * 91 = 1729 --> the number that we started with.

Complete the function which tests if a positive integer n is Harshad number, and returns True if the product of its digit sum and its digit sum reversed equals n; otherwise return False.
"""

#0
def number_joy(n):
    sum_ = sum([int(i) for i in str(n)])
    rev_sum = int(str(sum_)[::-1])
    return sum_ * rev_sum == n

"""# Задача 371(7) **Anagram Detection**

An anagram is the result of rearranging the letters of a word to produce a new word (see wikipedia).

Note: anagrams are case insensitive

Complete the function to return true if the two arguments given are anagrams of each other; return false otherwise.

Examples
"foefet" is an anagram of "toffee"

"Buckethead" is an anagram of "DeathCubeK"


is_anagram("foefet", "toffee"), True, 'The word foefet is an anagram of toffee')

is_anagram("Buckethead", "DeathCubeK"), True, 'The word Buckethead is an anagram of DeathCubeK')

is_anagram("Twoo", "WooT"), True, 'The word Twoo is an anagram of WooT')

is_anagram("dumble", "bumble"), False, 'Characters do not match for test case dumble, bumble')

is_anagram("ound", "round"), False, 'Missing characters for test case ound, round')

is_anagram("apple", "pale"), False, 'Same letters, but different count')
"""

#0
def is_anagram(test, original):
    
    if len(test) != len(original):
        return False
    
    test = test.lower()
    original = original.lower()
    
    lst_org = list(original)
    
    for i in range(len(test)):
        if test[i] not in lst_org:
            return False
        char = test[i]
        lst_org[lst_org.index(char)] = 0
        
    return True

#1
def is_anagram(test, original):
    return sorted(original.lower()) == sorted(test.lower())


#2
from collections import Counter

def is_anagram(test, original):
    return Counter(test.lower()) == Counter(original.lower())

#3
from operator import eq
from collections import Counter

def is_anagram(test, original):
    return eq(*map(Counter, map(str.lower, (test, original))))

"""# Задача 371(2) Unscrambled eggs

Unscramble the eggs.

The string given to your function has had an "egg" inserted directly after each consonant. You need to return the string before it became eggcoded.

Example
unscrambleEggs("Beggegeggineggneggeregg"); => "Beginner"
//             "B---eg---in---n---er---"

Kata is supposed to be for beginners to practice regular expressions, so commenting would be appreciated.

unscramble_eggs("ceggodegge heggeregge"), "code here")

unscramble_eggs("FeggUNegg KeggATeggA"),"FUN KATA")
"""

#0
def unscramble_eggs(word):
    lst = word.split('egg')
    for i, item in enumerate(lst):
        if 'egg' in item:
            lst.pop(i)
    return ''.join(lst)

#1
def unscramble_eggs(word):
    return word.replace('egg','')

#2
from re import sub
def unscramble_eggs(word):
    # Geggoodegg Legguceggkegg!
    return sub(r'([^aieou])egg',r'\1', word)

#3
import re

def unscramble_eggs(word):
    return re.sub("(?<=[^aeiou])egg", "", word)

#4
import re

def unscramble_eggs(word):
    return re.sub(r'egg', r'', word, flags=re.I)

#5
import re

def unscramble_eggs(word):
  return re.sub(r'([^aeiouAEIOU])egg', r'\1', word)