# -*- coding: utf-8 -*-
"""CodeWars - 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Wnzd22SZVkCrf371_J7Z0NnFXMguT1lD

# Задача 216(7) Alphabet symmetry

Consider the word "abode". We can see that the letter a is in position 1 and b is in position 2. In the alphabet, a and b are also in positions 1 and 2. Notice also that d and e in abode occupy the positions they would occupy in the alphabet, which are positions 4 and 5.

Given an array of words, return an array of the number of letters that occupy their positions in the alphabet for each word. For example,

solve(["abode","ABc","xyzD"]) = [4, 3, 1]

See test cases for more examples.

Input will consist of alphabet characters, both uppercase and lowercase. No spaces.

Good luck!
"""

#0
def solve(arr):
    l = []
    for i in arr:
        l.append(i.lower())
    lst = []
    s = 'abcdefghijklmnopqrstuvwxyz'
    for i in l:
        count = 0
        for j, item in enumerate(i):
            if j == s.index(item):
                count += 1
        lst.append(count)
    return lst


#1
def solve(arr):
    l = []
    for i in arr:
        l.append(i.lower())
    lst = []
    s = 'abcdefghijklmnopqrstuvwxyz'
    for i in l:
        lst.append(sum([j == s.index(item) for j, item in enumerate(i)]))
    return lst

#2
def solve(arr):
    arr = [i.lower() for i in arr]
    lst = []
    s = 'abcdefghijklmnopqrstuvwxyz'
    for i in arr:
        lst.append(sum([j == s.index(item) for j, item in enumerate(i)]))
    return lst

#3
def solve(arr):
    s = 'abcdefghijklmnopqrstuvwxyz'
    return [sum([j == s.index(item) for j, item in enumerate(i.lower())]) for i in arr]

#0 
def solve(arr):
    return [ sum(c == chr(97+i) for i,c in enumerate(w[:26].lower())) for w in arr ]

#1
def solve(words):
  return [sum(a==b for a, b in zip(w.lower(), 'abcdefghijklmnopqrstuvwxyz')) for w in words]

#2
def solve(arr):
    return [sum(ord(c.lower()) == i for i, c in enumerate(w, 97)) for w in arr]

"""# Задача 217(7) Cost of my ride

This Kata is intended as a small challenge for my students

Create a function, called insurance(), that computes the cost of renting a car. The function takes 3 arguments: the age of the renter, the size of the car, and the number days for the rental. The function should return an integer number of the calculated total cost of the rental.

Age (integer) : There is a daily charge of $10 if the driver is under 25

Car Size (string) : There may be an additional daily charge based on the car size:

car size surcharge "economy" $0 "medium" $10 "full-size" $15

Rental Days (integer) : There is a base daily charge of $50 for renting a car. Simply multiply the one day cost by the number of days the car is rented in order to get the full cost.

Note: Negative rental days should return 0 cost. Any other car size NOT listed should come with a same surcharge as the "full-size", $15.

insurance(18, "medium", 7); // => 490

insurance(30,"full-size",30); // => 1950

insurance(21,"economy",-10); // => 0

insurance(42,"my custom car",7); // => 455
"""

#0
def insurance(age, size, num_of_days): 
    s1 = 0
    s2 = 0 
    s3 = 0
    
    if num_of_days > 0:
        s3 = num_of_days * 50
    else:
        return 0
    
    if size == "medium":
        s2 += 10 * num_of_days
    elif size == "economy":
        s2 += 0
    else:
        s2 += 15 * num_of_days
    
    
    if age < 25:
        s1 += 10 * num_of_days
    
    return s1+s2+s3

#1
def insurance(age, size, num_of_days): 
    
    if num_of_days <= 0:
        return 0
    
    cost = 0
    one_day_cost = 50
      
    if size == "medium":
        one_day_cost += 10
        
    elif size != 'economy':
        one_day_cost += 15
        
    if age<25:
        one_day_cost += 10
        
    cost = one_day_cost * num_of_days
    return cost

#1
sc={'economy':0,'medium':10,'full-size':15}

def insurance(a,s,n): 
    return (50+(a<25)*10+sc.get(s,15))*max(0,n)

#2
sc={'economy':0,'medium':10,'full-size':15}

def insurance(a,s,n): 
    return (50+(a<25)*10+sc.get(s,15))*max(0,n)

#3
SIZES = {'full-size':15, 'medium':10, 'economy':0}

    
def insurance(age, size, num_of_days): 
    return max(0,num_of_days) * ( 50 + 10*(age<25) + SIZES.get(size,15) )

"""# Задача 218(7) Strings: swap vowels' case

Special thanks to SteffenVogel_79 for the idea.

Challenge:

Given a string, return a copy of the string with the vowels' case swapped.

For this kata, assume that vowels are in the set "aeouiAEOUI".

Example: Given a string "C is alive!", your function should return "C Is AlIvE!"

Addendum: Your solution is only required to work for the ASCII character set.

Please make sure you only swap cases for the vowels.

swap_vowel_case(" "), " ")

swap_vowel_case("C Is AlIvE!"), "C is alive!")

swap_vowel_case("to"), "tO"

swap_vowel_case("The"), "ThE")
"""

#0 
def swap_vowel_case(st): 
    vowels_low = "aeoui"
    vowels_up =  "AEUIO"
    lst = []
    for i, item in enumerate(st):
        if item in vowels_low:
            lst.append(item.upper())
        elif item in vowels_up:
            lst.append(item.lower())
        else:
            lst.append(item)
    return "".join(lst)

#1
def swap_vowel_case(st): 
    return "".join(x.swapcase() if x in "aeiouAEIOU" else x for x in st)

#2
T = str.maketrans("aiueoAIUEO", "AIUEOaiueo")

def swap_vowel_case(s):
    return s.translate(T)

#3
swap_vowel_case=lambda s:s.translate(s.maketrans('AEIOUaeiou','aeiouAEIOU'))

#4
def swap_vowel_case(st): 
    vowl = 'aeouiAEOUI'
    for char in st: 
        if char in vowl: 
            st = st.replace(char, char.swapcase())
    return st

#5
def swap_vowel_case(st): 
    return ''.join({
        'a': 'A', 'A': 'a', 'i': 'I', 'I': 'i', 'o': 'O',
        'u': 'U', 'U': 'u', 'e': 'E', 'E': 'e', 'O': 'o'
    }.get(x, x) for x in st)

"""# Задача 219(7) Remove duplicate words

Your task is to remove all duplicate words from a string, leaving only single (first) words entries.

Example:

Input:

'alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta'

Output:

'alpha beta gamma delta'
"""

#0 
def remove_duplicate_words(s):
    lst = []
    for i in s.split():
        if i not in lst:
            lst.append(i)
    return " ".join(lst)

#1
def remove_duplicate_words(s):
    return ' '.join(dict.fromkeys(s.split()))

#2
def remove_duplicate_words(s):
    return ' '.join(sorted(set(s.split()), key = s.index))

#3
def remove_duplicate_words(s):
    a=[]
    [a.append(v) for v in s.split(" ") if v not in a]
    return str(" ").join(a)

#4
from collections import OrderedDict
remove_duplicate_words=lambda s:' '.join(OrderedDict.fromkeys(s.split(' ')))

#5
def remove_duplicate_words(s):
    return ' '.join({i:0 for i in s.split()})

"""# Задача 220(7) Sequence Determiner

A sequence of numbers is called an Arithmetic Progression if the difference between any two consecutive terms is always same. In simple terms, it means that next number in the series is calculated by adding a fixed number to the previous number in the series. This fixed number is called the common difference.

A sequence of numbers is called a Geometric Progression if the ratio of any two consecutive terms is always same. In simple terms, it means that next number in the series is calculated by multiplying a fixed number to the previous number in the series. This fixed number is called the common ratio.

Rules
Given an array of integers that follow either series, you have to determine the series and return accordingly :

"0" if it is an AP

"1" if it is a GP

"-1" if it doesn't follow any of the above sequences

"2" if it is both an AP and GP

For Example,

  series_array = [2, 5, 8, 11, 14]   #should return 0

  series_array = [1, 2, 4, 8, 16]    #should return 1

  series_array = [1, 2, 1, 3, 4, 5]  #should return -1

  series_array = [1, 1, 1, 1, 1]     #should return 2

  series_array = [0, 0, 0, 0, 0]     #should return 0

The main challenge is identifying the differences between the 2 sequences and to find a way of determining each sequence

If the series has all 0's, then 0 should be returned as it is not accepted as a term GP

NOTE : Only APs and GPs are considered in this question. Other series like Harmonic Progression are not considered and assume that the array will have atleast


determine_sequence([2, 5, 8, 11, 14]), 0) #It is an AP

determine_sequence([1, 2, 4, 8, 16]), 1) #It is a GP

determine_sequence([1, 2, 1, 3, 4, 5]), -1) #It is not a series

determine_sequence([1, 1, 1, 1, 1]), 2) #It is both an AP and GP

determine_sequence([1, 0, 0, 0, 0]), -1)

determine_sequence([100, 0, 0, 0, 0]), -1)
"""

#0 
def determine_sequence(series_array):
    
    AP = 0 
    GP = 0
    
    if sum(series_array) == 0:
        return 0
    
    for i in series_array:
        if i == 0:
            return -1
    
    
    for i  in range(1):
        
        if series_array[i+1] == series_array[i] and  series_array[i+2] == series_array[i+1] and series_array[i+3] == series_array[i+2]:
            return 2
        
        if series_array[i+1] - series_array[i] == series_array[i+2] - series_array[i+1] and series_array[i+2] - series_array[i+1] == series_array[i+3] - series_array[i+2] and series_array[i+3] - series_array[i+2] == series_array[i+4] - series_array[i+3]:
            AP = 1
        if series_array[i+1] / series_array[i] == series_array[i+2] / series_array[i+1] and series_array[i+2] / series_array[i+1] == series_array[i+3] / series_array[i+2] and series_array[i+3] / series_array[i+2] == series_array[i+4] / series_array[i+3]:
            GP = 1
    
    if AP: return 0
    if GP: return 1
        
    return -1

#1

def determine_sequence(a):
    ap = a[0]-a[1] == a[1]-a[2] and a[0]-a[1] == a[2]-a[3] and a[0]-a[1] == a[3]-a[4]
    try: gp = a[0]/a[1] == a[1]/a[2] and a[0]/a[1] == a[2]/a[3] and a[0]/a[1] == a[3]/a[4]
    except: gp = False
    return 2 if ap and gp else 0 if ap else 1 if gp else -1

"""# Задача 221(8) Filtering even numbers (Bug Fixes)

Fix the bug in Filtering method
The method is supposed to remove even numbers from the list and return a list that contains the odd numbers.

However, there is a bug in the method that needs to be resolved.

kata_13_december([1, 2, 2, 2, 4, 3, 4, 5, 6, 7]), [1, 3, 5, 7])

kata_13_december([1, 2, 2, 2, 4, 3, 4]), [1, 3])

  def kata_13_december(lst): 
      # Fix this code
      for i in range(len(lst)): 
          if lst[i]%2==0: 
              lst.remove(i)
      return lst
"""

#0
def kata_13_december(lst): 
    for i in range(len(lst)-1, -1, -1): 
        if lst[i] % 2 == 0: 
            del lst[i]
    return lst

#1
def kata_13_december(lst):
    return [item for item in lst if item & 1]

#2
def kata_13_december(lst): 
    return [x for x in lst if x % 2]

#3
def kata_13_december(lst): 
    new = list()
    for i in range(len(lst)): 
        if lst[i] % 2 != 0: 
            new.append(lst[i])
    return new

#4
kata_13_december = lambda l: [e for e in l if e % 2]

#5
def kata_13_december(lst):
    return list(filter(1 .__and__, lst))

#6
def kata_13_december(lst):
    return [i for c, i in enumerate(lst) if i%2==1 and i in lst[c:]]

"""# Задача 222(8) Enumerable Magic 1 - True for All?

Task

Create a method all which takes two params:

a sequence
a function (function pointer in C)
and returns true if the function in the params returns true for every element in the sequence. Otherwise, it should return false. If the sequence is empty, it should return true, since technically nothing failed the test.

greater_than_9 = lambda x: x>9

less_than_9 = lambda x: x<9

Example

all((1, 2, 3, 4, 5), greater_than_9) -> false

all((1, 2, 3, 4, 5), less_than_9)    -> True
"""

#0
def _all(seq, fun):
        return all(map(fun,seq))

#1
def all(seq, fun): 
    return not False in list(map(fun, seq))

#2
def all(seq, fun):
    return next((False for x in seq if not fun(x)), True)

#3
def all(seq, fun): 
    for item in seq: 
        if not fun(item): 
            return False
    return True

#4
def all(seq, fun): 
    return False if False in map(fun, seq) else True

#5
def _all(seq, fun):
    return all([fun(x) for x in seq])

"""# Задача 223(8) Job Matching #1

Let's build a matchmaking system that helps discover jobs for developers based on a number of factors.

One of the simplest, yet most important factors is compensation. As developers we know how much money we need to support our lifestyle, so we generally have a rough idea of the minimum salary we would be satisfied with.

Let's give this a try. We'll create a function match which takes a candidate and a job, which will return a boolean indicating whether the job is a valid match for the candidate.

A candidate will have a minimum salary, so it will look like this:

**candidate = {'min_salary': 120000}**

A job will have a maximum salary, so it will look like this:

**job = {'max_salary': 140000}**

If either the candidate's minimum salary or the job's maximum salary is not present, throw an error.

For a valid match, the candidate's minimum salary must be less than or equal to the job's maximum salary. However, let's also include 10% wiggle room (deducted from the candidate's minimum salary) in case the candidate is a rockstar who enjoys programming on Codewars in their spare time. The company offering the job may be able to work something out.
"""

#0
def match(candidate, job):
    up = candidate['min_salary'] + candidate['min_salary'] * 0.1
    down = candidate['min_salary'] - candidate['min_salary'] * 0.1
    if down <= job['max_salary'] or up <= job['max_salary']:
        return True
    else: 
        return False

#1
def match(candidate, job):
    return candidate['min_salary'] * 0.9 <= job['max_salary']

#2
match = lambda c,j: j['max_salary'] >= c['min_salary']*0.9

"""# Задача 224(8) USD => CNY

Create a function that converts US dollars (USD) to Chinese Yuan (CNY) . The input is the amount of USD as an integer, and the output should be a string that states the amount of Yuan followed by 'Chinese Yuan'

For Example:

  usdcny(15)  => '101.25 Chinese Yuan'

  usdcny(465) => '3138.75 Chinese Yuan'
  
The conversion rate you should use is 6.75 CNY for every 1 USD. All numbers shold be rounded to 2 decimal places. (e.g. "21.00" NOT "21.0" or "21")
"""

#0
def usdcny(usd):
    cny = usd * 6.75
    return "{0:.2f} Chinese Yuan".format(cny)

#1
COURSE = 6.75  # CNY == 1 USD


def usdcny(usd):
    return f"{usd * COURSE:.2f} Chinese Yuan"

#2
def usdcny(usd):
    return f"{(usd * 6.75):.2f} Chinese Yuan"

#3
def usdcny(usd):
    cny = usd * 6.75
    return "{:.2f} Chinese Yuan".format(cny)

#4
def usdcny(usd):
    yuan = format(usd * 6.75, '.2f')
    return '{} Chinese Yuan'.format(yuan)

"""# Задача 225 Pandemia 🌡️

⚠️ The world is in quarantine! There is a new pandemia that struggles mankind. Each continent is isolated from each other but infected people have spread before the warning. ⚠️

🗺️ You would be given a map of the world in a type of string:

string s = "01000000X000X011X0X"

'0' : uninfected

'1' : infected

'X' : ocean
⚫ The virus can't spread in the other side of the ocean.

⚫ If one person is infected every person in this continent gets infected too.

⚫ Your task is to find the percentage of human population that got infected in the end.

☑️ Return the percentage % of the total population that got infected.

❗❗ The first and the last continent are not connected!

💡 Example:

 start: map1 = "01000000X000X011X0X"

 end:   map1 = "11111111X000X111X0X"

 total = 15

 infected = 11

 percentage = 100*11/15 = 73.33333333333333

➕ For maps without oceans "X" the whole world is connected.

➕ For maps without "0" and "1" return 0 as there is no population.

("01000000X000X011X0X",73.33333333333333),

("01X000X010X011XX", 72.72727272727273),

("XXXXX", 0),

("00000000X00X0000", 0),

("0000000010", 100),

("000001XXXX0010X1X00010", 100),

 ("X00X000000X10X0100",42.857142857142854)
"""

0#
def infected(s):
    if '0' not in s and '1' not in s:
        return 0
    if '1' in s and 'X' not in s:
        return 100
    if '1' not in s:
        return 0
    
    c = 0
    lst = []
    
    s1 = s
    s1 = s1.replace('X','')
    c1 = len(s1)
    
    for i in s:
        lst.append(i)
        if i == 'X':
            if '1' in lst:
                c += len(lst) - 1 
                lst = []
            else:
                lst=[]
                
    if '1' in lst:
        c += len(lst)
        
    return c*100/c1

#1
def infected(s):
    lands = s.split('X')
    total = sum(map(len, lands))
    infected = sum(len(x) for x in lands if '1' in x)
    return infected * 100 / (total or 1)

#2
def infected(s):
    total_population = s.split('X')
    total = 0
    infected = 0
    for population in total_population:
        if "1" in population:
            infected += len(population)
        total += len(population)
    
    try:
        return (100 * infected) / total
    except ZeroDivisionError:
        return 0
  
#3
def infected(s):
    inf=0
    saf=0
    for c in s.split('X') :
        if '1' in c :
            inf += len(c)
        else :
            saf += len(c)
        
    return 0 if inf+saf==0 else inf/(inf+saf)*100

#4
def infected(s):
    total = len(s)-s.count('X')
    infected = sum([len(i) for i in s.split('X') if '1' in i])
    return infected/total*100 if total > 0 else infected

"""# Задача 226(7) Convert Decimal Degrees to Degrees, Minutes, Seconds

Convert Decimal Degrees to Degrees, Minutes, Seconds.

Remember: 1 degree = 60 minutes; 1 minute = 60 seconds.

Input: Positive number.

Output: Array [degrees, minutes, seconds]. E.g [30, 25, 25]

Trailing zeroes should be omitted in the output. E.g

convert (50) 

//correct output -> [50] 

//wrong output -> [50, 0, 0]

convert(80.5)

//correct output -> [ 80, 30 ]

//wrong output -> [80, 30, 0]

convert(0.0001388888888888889)

//correct output -> [ 0, 0, 1 ]

//wrong output -> [1]

Round the seconds to the nearest integer.

convert(0),[0], "0 degrees");

convert(40.567), [40, 34, 1], "40 degrees, 34 minutes, 1 second");

convert(80.5),[ 80, 30 ], "70 degrees, 14 minutes, 2 seconds");

len(convert(70.234)), 3, "Length of the array should be 3");

convert(20.999), [20, 59, 56], "20 degrees, 59 minutes, 56 second");

convert(33.333)[1], 19, "Should return 19 minutes");

convert(50),[50], "50 degrees");

convert(0.0001398888888888889),[ 0, 0, 1 ], "0 degrees, 0 minutes, 1 second");

convert(0.0001388888888888888),[ 0 ], "0 degrees, 0 minutes, 0 second");
"""

#1
def convert(degrees): 
    m = (degrees % 1) * 60
    s = round((m % 1) * 60)
    d, m, s = map(int, [degrees, m, s])
    return [d, m, s] if s else [d, m] if m else [d]

#2
def convert(degrees): 
    minutes = degrees % 1 * 60
    seconds = round(minutes % 1 * 60)
    arr = [int(degrees), int(minutes), seconds]
    return [arr[0]] if not arr[1] and not arr[2] else arr[:2] if not arr[2] else arr

#3
def convert(degrees): 
    deg = int(degrees)
    minutes = (degrees-deg)*60
    mins = int(minutes)
    seconds = (minutes-mins)*60
    secs = round(seconds)
    if secs:
        return [deg, mins, secs]
    if mins:
        return [deg, mins]
    return [deg]

"""# Задача 227(7) All Inclusive?

Input:

a string strng
an array of strings arr
Output of function contain_all_rots(strng, arr) (or containAllRots or contain-all-rots):

a boolean true if all rotations of strng are included in arr (C returns 1)
false otherwise (C returns 0)

Examples:

contain_all_rots(
  "bsjq", ["bsjq", "qbsj", "sjqb", "twZNsslC", "jqbs"]) -> true

contain_all_rots(
  "Ajylvpy", ["Ajylvpy", "ylvpyAj", "jylvpyA", "lvpyAjy", "pyAjylv", "vpyAjyl", "ipywee"]) -> false)

Note:

Though not correct in a mathematical sense

we will consider that there are no rotations of strng == ""

and for any array arr: contain_all_rots("", arr) --> true
"""

#0  Не все тесты проходит
def contain_all_rots(strng, arr):
    
    if strng == "":
        return True
    
    l = len(strng)
    c = 0
    
    for i in arr:
        c1 = 0
        for j in strng:
            if j in i:
                c1 += 1
        if c1 == l:
            c += 1
    
    return c == l

#1
def contain_all_rots(strng, arr):
    """Test if list arr contains all the rotations of the string strng."""
    for _ in range(len(strng)):
        if not strng in arr:
            return False
        strng = strng[1:] + strng[0]
    return True

#2
def contain_all_rots(strng, arr):
    if strng == "":
        return True

    for i in range(len(arr)):
        if strng in arr:
            strng = strng[-1] + strng[:-1]
        else:
            return False
    return True

#3
def contain_all_rots(s, l):
    return all(s[i:]+s[:i] in l for i in range(len(s)))

#4
def contain_all_rots(strng, arr):
    all_rotations = [strng[i:] + strng[:i] for i in range(len(strng))]
    return all(rotation in arr for rotation in all_rotations)

#5
def contain_all_rots(strng, arr):
    if strng == "": return True
    i, l = 0, len(strng)
    while i < l:
        strng = strng[-1]+strng[:-1]
        if not strng in arr: return False
        i += 1
    return True

"""# Задача 228(7) Pairs of integers from m to n

Implement a function that receives two integers m and n and generates a sorted list of pairs (a, b) such that m <= a <= b <= n.

Example:

m = 2
n = 4

result = [(2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (4, 4)]
"""

#0
def generate_pairs(m, n):
    lst = []
    
    while m <= n:
        x = m 
        
        while x <= n:
            lst.append((m,x))
            x += 1
            
        m += 1
    
    return lst

#1
from itertools import combinations_with_replacement
def generate_pairs(m, n):
    return list(combinations_with_replacement(range(m,n+1),2))

#2
def generate_pairs(m, n):
    return [(i, j) for i in range(m, n + 1) for j in range(i, n + 1)]

#3  Тоже что и #2 
def generate_pairs(m, n):
    lst = []
    for i in range(m, n + 1):
        for j in range(i, n + 1):
            lst.append((i,j))

#4
generate_pairs=lambda x,y:list(__import__("itertools").combinations_with_replacement(range(x,y+1),2))

"""# Задача 229 (7) Single digit

The goal of this Kata is to reduce the passed integer to a single digit (if not already) by converting the number to binary, taking the sum of the binary digits, and if that sum is not a single digit then repeat the process.

n will be an integer such that 0 < n < 10^20

If the passed integer is already a single digit there is no need to reduce

For example given 5665 the function should return 5:

5665 --> (binary) 1011000100001

1011000100001 --> (sum of binary digits) 5

Given 123456789 the function should return 1:

123456789 --> (binary) 111010110111100110100010101

111010110111100110100010101 --> (sum of binary digits) 16

16 --> (binary) 10000

10000 --> (sum of binary digits) 1

single_digit(5665), 5)

single_digit(123456789), 1)
"""

#0
def single_digit(n):
    while n > 9:
        n = bin(n)
        n = n.count("1")
    return n

#1
def single_digit(n):
    while n > 9:
        n = bin(n).count("1")
    return n

#1  Рекурсия 
def single_digit(n):
  return n if n<10 else single_digit(bin(n).count("1"))

#2
def single_digit(n):
    while n/10>=1:
        n=sum(map(int, bin(n)[2:]))
    return n

#3
def single_digit(n):
    while n >= 10:
        n = sum(c == '1' for c in bin(n))
    return n

#4
def single_digit(n):
    while n>9:
        n=len([i for i in bin(n) if i=='1'])
    return n

"""# Задача 230(7) Functional Addition

reate a function add(n)/Add(n) which returns a function that always adds n to any number

Note for Java: the return type and methods have not been provided to make it a bit more challenging.

add_one = add(1)

add_one(3)  # 4

add_three = add(3)

add_three(3) # 6
"""

#0
def add(n):
    return lambda x: x + n

#1
def add(n):
    def adder(x):
        return x + n
    return adder

#2
add = lambda n: lambda x: x + n

Метод center( width, [fill] ) возвращает строку длиной width, 
в которой исходная строка находится в центре, а справа и слева от нее находятся символы указанные в fillchar ( по умолчанию пробел ).

str = 'python Scripts'

str.center(16, '_')
# _python Scripts_